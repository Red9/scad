//
// automatically generated by spin2cpp v1.01 on Wed Dec 12 21:35:05 2012
// spin2cpp.linux --main test_nl.spin 
//

#include <propeller.h>
#include "securedigitalcard.h"
#include <stdio.h>

static int32_t Min__(int32_t a, int32_t b) { return a < b ? a : b; }
static int32_t Shr__(uint32_t a, uint32_t b) { return (a>>b); }
void SecureDigitalCard::Release(void)
{
  Sdspi.Release();
}

int SecureDigitalCard::Writeblock2(int N, char * B)
{
  int32_t result = 0;
  Errno = Sdspi.Writeblock(N, B);
  if (Errno < 0) {
    return Errno;
  }
  if (N >= Fat1) {
    if (N < (Fat1 + Sectorsperfat)) {
      Errno = Sdspi.Writeblock((N + Sectorsperfat), B);
      if (Errno < 0) {
        return Errno;
      }
    }
  }
  return result;
}

int32_t SecureDigitalCard::Flushifdirty(void)
{
  int32_t result = 0;
  if (Dirty) {
    Errno = Writeblock2(Lastread, (char *)(&Buf2));
    if (Errno < 0) {
      return Errno;
    }
    Dirty = 0;
  }
  return result;
}

int32_t SecureDigitalCard::Readblockc(int32_t N)
{
  int32_t result = 0;
  if (N != Lastread) {
    Errno = Flushifdirty();
    if (Errno < 0) {
      return Errno;
    }
    Errno = Sdspi.Readblock(N, (char *)(&Buf2));
    if (Errno < 0) {
      return Errno;
    }
    Lastread = N;
  }
  return result;
}

int SecureDigitalCard::Brword(char * b)
{
  return ((b)[0] + ((b)[1] << 8));
}

int SecureDigitalCard::Brlong(char * B)
{
  return (Brword(B) + (Brword((B + 2)) << 16));
}

int SecureDigitalCard::Brclust(char * B)
{
  if (Filesystem == 1) {
    return Brword(B);
  } else {
    return Brlong(B);
  }
}

//int32_t SecureDigitalCard::Brwword(int32_t W, int32_t V)
//{
//  int32_t result = 0;
//  ((uint8_t *)(W++))[0] = V;
//  ((uint8_t *)W)[0] = (Shr__(V, 8));
//  Dirty = 1;
//  return result;
//}
void SecureDigitalCard::Brwword(char *w, int v)
{
   w++[0] = v ;
   w[0] = v >> 8 ;
   Dirty = 1 ;
}

//int32_t SecureDigitalCard::Brwlong(int32_t W, int32_t V)
//{
//  int32_t result = 0;
//  Brwword(W, V);
//  Brwword((W + 2), (Shr__(V, 16)));
//  return result;
//}

void SecureDigitalCard::Brwlong(char *w, int v)
{
   Brwword(w, v) ;
   Brwword(w+2, v >> 16) ;
}

//int32_t SecureDigitalCard::Brwclust(int32_t W, int32_t V)
//{
//  int32_t result = 0;
//  if (Filesystem == 1) {
//    Brwword(W, V);
//  } else {
//    Brwlong(W, V);
//  }
//  return result;
//}
void SecureDigitalCard::Brwclust(char *w, int v) {
//
//   Write a cluster entry.
   if (Filesystem == 1) {
     Brwword(w, v) ;
   } else {
     Brwlong(w, v) ;
   }
}

int SecureDigitalCard::Unmount(void)
{
  int32_t result = 0;
  Errno = Close();
  if (Errno < 0) {
    return Errno;
  }
  Sdspi.Stop();
  return result;
}

int SecureDigitalCard::Getfstype(void)
{
//TODO (SRLM): I don't think I need this cast here?

  if ((Brlong(((char *)(&Buf) + 54)) == 0x31544146) && (Buf[58] == '6')) {
    return 1;
  }
  if ((Brlong(((char *)(&Buf) + 82)) == 0x33544146) && (Buf[86] == '2')) {
    return 2;
  }
  return 0;
}




int SecureDigitalCard::Mount(int Do, int Clk, int Di, int Cs)
{
  int32_t	Start, Sectorspercluster, Reserved, Rootentries, Sectors;
  if (Pdate == 0) {
    SetDate(2013, 1, 1, 0, 0, 0);
  }
  
  //SRLM Addition: check to make sure that Buf and Buf2 are longword aligned.
  //Theoretically, this should have no runtime cost, but it looks like in CMM
  //and -Os it takes 16 bytes. It can be commented out if you're sure that
  //Buf and Buf2 are longword aligned.
  if( (( (int)Buf ) & 0b11) != 0)
    return -512;
  if( (( (int)Buf2 ) & 0b11) != 0)
    return -512;

  
  Errno = Unmount();
  if (Errno < 0) {
    return Errno;
  }
  Sdspi.Start_explicit(Do, Clk, Di, Cs);
  Lastread = (-1);
  Dirty = 0;
  Errno = Sdspi.Readblock(0, (char *)(&Buf));
  if (Errno < 0) {
    return Errno;
  }
  if (Getfstype() > 0) {
    Start = 0;
  } else {
    Start = Brlong(((char *)(&Buf) + 454));
    Errno = Sdspi.Readblock(Start, (char *)(&Buf));
    if (Errno < 0) {
      return Errno;
    }
  }
  Filesystem = Getfstype();
  if (Filesystem == 0) {
    return (-20);
  }
  if (Brword(((char *)(&Buf) + 11)) != Sectorsize) {
    return (-21);
  }
  Sectorspercluster = Buf[13];
  if (Sectorspercluster & (Sectorspercluster - 1)) {
    return (-22);
  }
  Clustershift = 0;
  while (Sectorspercluster > 1) {
    (Clustershift++);
    Sectorspercluster = (Shr__(Sectorspercluster, 1));
  }
  Sectorspercluster = (1 << Clustershift);
  Clustersize = (Sectorsize << Clustershift);
  Reserved = Brword(((char *)(&Buf) + 14));
  if (Buf[16] != 2) {
    return (-23);
  }
  Sectors = Brword(((char *)(&Buf) + 19));
  if (Sectors == 0) {
    Sectors = Brlong(((char *)(&Buf) + 32));
  }
  Fat1 = (Start + Reserved);
  if (Filesystem == 2) {
    Rootentries = (16 << Clustershift);
    Sectorsperfat = Brlong(((char *)(&Buf) + 36));
    Dataregion = ((Fat1 + (2 * Sectorsperfat)) - (2 * Sectorspercluster));
    Rootdir = ((Dataregion + (Brword(((char *)(&Buf) + 44)) << Clustershift)) << Sectorshift);
    Rootdirend = (Rootdir + (Rootentries << Dirshift));
    Endofchain = 268435440;
  } else {
    Rootentries = Brword(((char *)(&Buf) + 17));
    Sectorsperfat = Brword(((char *)(&Buf) + 22));
    Rootdir = ((Fat1 + (2 * Sectorsperfat)) << Sectorshift);
    Rootdirend = (Rootdir + (Rootentries << Dirshift));
    Dataregion = ((1 + (Shr__((Rootdirend - 1), Sectorshift))) - (2 * Sectorspercluster));
    Endofchain = 65520;
  }
  if (Brword(((char *)(&Buf) + 510)) != 43605) {
    return (-24);
  }
  Totclusters = (Shr__(((Sectors - Dataregion) + Start), Clustershift));
  return 0;
}

int SecureDigitalCard::Mount(int Basepin)
{
  return Mount(Basepin, (Basepin + 1), (Basepin + 2), (Basepin + 3));
}

char * SecureDigitalCard::Readbytec(int32_t Byteloc)
{
  int32_t result = 0;
  Errno = Readblockc((Shr__(Byteloc, Sectorshift)));
  if (Errno < 0) {
    return Errno;
  }
  return ((char *)(&Buf2) + (Byteloc & 0x1ff));
}

char * SecureDigitalCard::Readfat(int32_t Clust)
{
  Fatptr = ((Fat1 << Sectorshift) + (Clust << Filesystem));
  return Readbytec(Fatptr);
}

int32_t SecureDigitalCard::Followchain(void)
{
  char * temp;
  int32_t R = 0;
  temp = Readfat(Fclust);
  if ((int32_t)temp < 0) {
    return (int32_t)temp;
  }
  R = Brclust(temp);
  Writelink = Fatptr;
  return R;
}

int32_t SecureDigitalCard::Nextcluster(void)
{
  int32_t R = 0;
  R = Followchain();
  if (R < 0) {
    return R;
  }
  if ((R < 2) || (R >= Totclusters)) {
    return (-9);
  }
  return R;
}

int32_t SecureDigitalCard::Freeclusters(int32_t Clust)
{
  char *	Bp;
  
  while (Clust < Endofchain) {
    if (Clust < 2) {
      return (-26);
    }
    Bp = Readfat(Clust);
    if ((int)Bp < 0) {
      return (int)Bp;
    }
    Clust = Brclust(Bp);
    Brwclust(Bp, 0);
  }
  Errno = Flushifdirty();
  if (Errno < 0) {
    return Errno;
  }
  return 0;
}

int32_t SecureDigitalCard::Datablock(void)
{
  int32_t result = 0;
  return (((Fclust << Clustershift) + Dataregion) + ((Shr__(Floc, Sectorshift)) & ((1 << Clustershift) - 1)));
}

int32_t SecureDigitalCard::Uc(int32_t C)
{
  int32_t result = 0;
  if (('a' <= C) && (C <= 'z')) {
    return (C - 32);
  }
  return C;
}

int32_t SecureDigitalCard::Pflushbuf(int32_t Rcnt, int32_t Metadata)
{
  int32_t	Cluststart, Newcluster, Count, I;
  int32_t R = 0;
  if (Direntry == 0) {
    return (-27);
  }
  if (Rcnt > 0) {
    if (Frem < Sectorsize) {
      Newcluster = (-1);
      Cluststart = (Fclust & (~((Shr__(Sectorsize, Filesystem)) - 1)));
      Count = 2;
      while (1) {
        Errno = (int)Readfat(Cluststart);
        if (Errno < 0) {
          return Errno;
        }
        {
          int32_t _limit__0025 = (Sectorsize - (1 << Filesystem));
          int32_t _step__0026 = (1 << Filesystem);
          I = 0;
          if (I >= _limit__0025) _step__0026 = -_step__0026;
          do {
            if (Buf2[I] == 0) {
              if (Brclust(((char *)(&Buf2) + I)) == 0) {
                Newcluster = (Cluststart + (Shr__(I, Filesystem)));
                if (Newcluster >= Totclusters) {
                  Newcluster = (-1);
                }
                break;
              }
            }
            I = (I + _step__0026);
          } while (((_step__0026 > 0) && (I <= _limit__0025)) || ((_step__0026 < 0) && (I >= _limit__0025)));
        }
        if (Newcluster > 1) {
          Brwclust(((char *)(&Buf2) + I), (Endofchain + 15));
          if (Writelink == 0) {
            Brwword((Readbytec(Direntry) + 26), Newcluster);
            Writelink = (Direntry & (Sectorsize - Filesystem));
            Brwlong((((char *)(&Buf2) + Writelink) + 28), (Floc + Bufat));
            if (Filesystem == 2) {
              Brwword((((char *)(&Buf2) + Writelink) + 20), (Shr__(Newcluster, 16)));
            }
          } else {
            Brwclust(Readbytec(Writelink), Newcluster);
          }
          Writelink = (Fatptr + I);
          Fclust = Newcluster;
          Frem = Clustersize;
          break;
        } else {
          Cluststart = (Cluststart + (Shr__(Sectorsize, Filesystem)));
          if (Cluststart >= Totclusters) {
            Cluststart = 0;
            (Count--);
            if (Rcnt < 0) {
              Rcnt = (-5);
              break;
            }
          }
        }
      }
    }
    if (Frem >= Sectorsize) {
      Errno = Sdspi.Writeblock(Datablock(), (char *)(&Buf));
      if (Errno < 0) {
        return Errno;
      }
      if (Rcnt == Sectorsize) {
        Floc = (Floc + Rcnt);
        Frem = (Frem - Rcnt);
        Bufat = 0;
        Bufend = Rcnt;
      }
    }
  }
  if ((Rcnt < 0) || (Metadata)) {
    Errno = Readblockc((Shr__(Direntry, Sectorshift)));
    if (Errno < 0) {
      return Errno;
    }
    Brwlong((((char *)(&Buf2) + (Direntry & (Sectorsize - Filesystem))) + 28), (Floc + Bufat));
    Errno = Flushifdirty();
    if (Errno < 0) {
      return Errno;
    }
  }
  if (Rcnt < 0) {
    return Rcnt;
  }
  return Rcnt;
}

int32_t SecureDigitalCard::Pflush(void)
{
  int32_t result = 0;
  return Pflushbuf(Bufat, 1);
}

int32_t SecureDigitalCard::Pfillbuf(void)
{
  int32_t R = 0;
  if (Floc >= Filesize) {
    return (-1);
  }
  if (Frem == 0) {
    Fclust = Nextcluster();
    if (Fclust < 0) {
      return Fclust;
    }
    Frem = (Min__(Clustersize, (Filesize - Floc)));
  }
  Errno = Sdspi.Readblock(Datablock(), (char *)(&Buf));
  if (Errno < 0) {
    return Errno;
  }
  R = Sectorsize;
  if ((Floc + R) >= Filesize) {
    R = (Filesize - Floc);
  }
  Floc = (Floc + R);
  Frem = (Frem - R);
  Bufat = 0;
  Bufend = R;
  return R;
}

int SecureDigitalCard::Close(void)
{
  int R = 0;
  if (Direntry) {
    R = Pflush();
    if (R < 0) {
      return R;
    }
  }
  Bufat = 0;
  Bufend = 0;
  Filesize = 0;
  Floc = 0;
  Frem = 0;
  Writelink = 0;
  Direntry = 0;
  Fclust = 0;
  Firstcluster = 0;
  Sdspi.Release();
  return R;
}

int SecureDigitalCard::SetDate(int Year, int Month, int Day, int Hour, int Minute, int Second)
{

  Pdate = ((((Year - 1980) << 25) + (Month << 21)) + (Day << 16));
  Pdate = (Pdate + (((Hour << 11) + (Minute << 5)) + (Shr__(Second, 1))));
  return Pdate;
}

int SecureDigitalCard::Open(const char * filename, const char Mode)
{
  char * S;// = Filename;
  int32_t	I, Sentinel, Dirptr, Freeentry;
  int R = 0;
  Errno = Close();
  if (Errno < 0) {
    return Errno;
  }
  I = 0;
  while (((I < 8) && ((filename)[0])) && ((filename)[0] != '.')) {
    Padname[(I++)] = Uc((filename++)[0]);
  }
  while (I < 8) {
    Padname[(I++)] = ' ';
  }
  while (((filename)[0]) && ((filename)[0] != '.')) {
    (filename++);
  }
  if ((filename)[0] == '.') {
    (filename++);
  }
  while ((I < 11) && ((filename)[0])) {
    Padname[(I++)] = Uc(((filename++))[0]);
  }
  while (I < 11) {
    Padname[(I++)] = ' ';
  }
  Sentinel = 0;
  Freeentry = 0;
  {
    int32_t _limit__0027 = (Rootdirend - Dirsize);
    int32_t _step__0028 = Dirsize;
    Dirptr = Rootdir;
    if (Dirptr >= _limit__0027) _step__0028 = -_step__0028;
    do {
      S = Readbytec(Dirptr);
      if ((int)S < 0) {
        return (int)S;
      }
      if ((Freeentry == 0) && (((S)[0] == 0) || ((S)[0] == 229))) {
        Freeentry = Dirptr;
      }
      if ((S)[0] == 0) {
        Sentinel = Dirptr;
        break;
      }
      I = 0;
      do {
        if (Padname[I] != (S)[I]) {
          break;
        }
        I = (I + 1);
      } while (I <= 10);
      if ((I == 11) && (0 == ((S)[11] & 0x18))) {
        Fclust = Brword((S + 26));
        if (Filesystem == 2) {
          Fclust = (Fclust + (Brword((S + 20)) << 16));
        }
        Firstcluster = Fclust;
        Filesize = Brlong((S + 28));
        
        //Mode is Read
        if (Mode == 'r') {
          Frem = (Min__(Clustersize, Filesize));
          return Filesize;
        }
        if ((S)[11] & 0xd9) {
          return (-6);
        }
        
        //Mode is Delete
        if (Mode == 'd') {
          Brwword(S, 229);
          if (Fclust) {
            Errno = Freeclusters(Fclust);
            if (Errno < 0) {
              return Errno;
            }
          }
          Errno = Flushifdirty();
          if (Errno < 0) {
            return Errno;
          }
          return Filesize;
        }
        
        //Mode is Write
        if (Mode == 'w') {
          Brwword((S + 26), 0);
          Brwword((S + 20), 0);
          Brwlong((S + 28), 0);
          Writelink = 0;
          Direntry = Dirptr;
          if (Fclust) {
            Errno = Freeclusters(Fclust);
            if (Errno < 0) {
              return Errno;
            }
          }
          Bufend = Sectorsize;
          Fclust = 0;
          Filesize = 0;
          Frem = 0;
          return Filesize;
        } 
        //Mode is Append
        else {
          if (Mode == 'a') {
            Frem = Filesize;
            Freeentry = Clustersize;
            if (Fclust >= Endofchain) {
              Fclust = 0;
            }
            while (Frem > Freeentry) {
              if (Fclust < 2) {
                return (-7);
              }
              Fclust = Nextcluster();
              if (Fclust < 0) {
                return Fclust;
              }
              Frem = (Frem - Freeentry);
            }
            Floc = (Filesize & 0xfffffe00);
            Bufend = Sectorsize;
            Bufat = (Frem & 0x1ff);
            Writelink = 0;
            Direntry = Dirptr;
            if (Bufat) {
              Errno = Sdspi.Readblock(Datablock(), (char *)(&Buf));
              if (Errno < 0) {
                return Errno;
              }
              Frem = (Freeentry - (Floc & (Freeentry - 1)));
            } else {
              if ((Fclust < 2) || (Frem == Freeentry)) {
                Frem = 0;
              } else {
                Frem = (Freeentry - (Floc & (Freeentry - 1)));
              }
            }
            if (Fclust >= 2) {
              Errno = Followchain();
              if (Errno < 0) {
                return Errno;
              }
            }
            return Filesize;
          } else {
            return (-3);
          }
        }
      }
      Dirptr = (Dirptr + _step__0028);
    } while (((_step__0028 > 0) && (Dirptr <= _limit__0027)) || ((_step__0028 < 0) && (Dirptr >= _limit__0027)));
  }
  if ((Mode != 'w') && (Mode != 'a')) {
    return (-1);
  }
  Direntry = Freeentry;
  if (Direntry == 0) {
    return (-2);
  }
  S = Readbytec(Direntry);
  if ((int)S < 0) {
    return (int)S;
  }
  memset( (void *)S, 0, 1*(Dirsize));
  memcpy( (void *)S, (void *)&Padname, 1*(11));
  Brwword((S + 26), 0);
  Brwword((S + 20), 0);
  I = Pdate;
  Brwlong((S + 14), I);
  Brwlong((S + 22), I);
  if ((Direntry == Sentinel) && ((Direntry + Dirsize) < Rootdirend)) {
    Brwword(Readbytec((Direntry + Dirsize)), 0);
  }
  Errno = Flushifdirty();
  if (Errno < 0) {
    return Errno;
  }
  Writelink = 0;
  Fclust = 0;
  Bufend = Sectorsize;
  return R;
}

int SecureDigitalCard::Get(char * Ubuf, int Count)
{
  int32_t	T;
  int32_t R = 0;
  while (Count > 0) {
    if (Bufat >= Bufend) {
      T = Pfillbuf();
      if (T <= 0) {
        return T;
      }
    }
    T = (Min__((Bufend - Bufat), Count));
    if (((T | (int)Ubuf) | Bufat) & 0x3) {
      memcpy( (void *)Ubuf, (void *)(void *)(((int32_t)(&Buf) + Bufat)), 1*(T));
    } else {
      memmove( (void *)Ubuf, (void *)(void *)(((int32_t)(&Buf) + Bufat)), 4*((Shr__(T, 2))));
    }
    Bufat = (Bufat + T);
    R = (R + T);
    Ubuf = (Ubuf + T);
    Count = (Count - T);
  }
  return R;
}

int SecureDigitalCard::Get(void)
{
  int32_t	T;
  int32_t result = 0;
  if (Bufat >= Bufend) {
    T = Pfillbuf();
    if (T < (-1)) {
      return T;
    }
    if (T <= 0) {
      return (-1);
    }
  }
  return Buf[(Bufat++)];
}

int SecureDigitalCard::Put(const char * Ubuf, int Count)
{
  int	T;
  int R = 0;
  while (Count > 0) {
    if (Bufat >= Bufend) {
      Errno = Pflushbuf(Bufat, 0);
      if (Errno < 0) {
        return Errno;
      }
    }
    T = (Min__((Bufend - Bufat), Count));
    if (((T | (int)Ubuf) | Bufat) & 0x3) {
      memcpy( (void *)(void *)(((int)(&Buf) + Bufat)), (void *)Ubuf, 1*(T));
    } else {
      memmove( (void *)(void *)(((int)(&Buf) + Bufat)), (void *)Ubuf, 4*((Shr__(T, 2))));
    }
    R = (R + T);
    Bufat = (Bufat + T);
    Ubuf = (Ubuf + T);
    Count = (Count - T);
  }
  return R;
}

int SecureDigitalCard::Put(const char * B)
{
  return Put(B, strlen(B));
}

int SecureDigitalCard::Put(const char C)
{
  if (Bufat == Sectorsize) {
    if (Pflushbuf(Sectorsize, 0) < 0) {
      return (-1);
    }
  }
  Buf[(Bufat++)] = C;
  return 0;
}

int SecureDigitalCard::Seek(int Pos)
{
  int32_t	Delta;
  if (((Direntry) || (Pos < 0)) || (Pos > Filesize)) {
    return (-1);
  }
  Delta = ((Floc - Bufend) & (-Clustersize));
  if (Pos < Delta) {
    Fclust = Firstcluster;
    Frem = (Min__(Clustersize, Filesize));
    Floc = 0;
    Bufat = 0;
    Bufend = 0;
    Delta = 0;
  }
  while (Pos >= (Delta + Clustersize)) {
    Fclust = Nextcluster();
    if (Fclust < 0) {
      return Fclust;
    }
    Floc = (Floc + Clustersize);
    Delta = (Delta + Clustersize);
    Frem = (Min__(Clustersize, (Filesize - Floc)));
    Bufat = 0;
    Bufend = 0;
  }
  if (((Bufend == 0) || (Pos < (Floc - Bufend))) || (Pos >= ((Floc - Bufend) + Sectorsize))) {
    Delta = (Floc + Frem);
    Floc = (Pos & 0xfffffe00);
    Frem = (Delta - Floc);
    Errno = Pfillbuf();
    if (Errno < (-1)) {
      return Errno;
    }
  }
  Bufat = (Pos & 0x1ff);
  return 0;
}

// TODO(SRLM): UNTESTED
//int SecureDigitalCard::Opendir(void)
//{
//  int32_t	Off;
//  int32_t result = 0;
//  Errno = Close();
//  if (Errno < 0) {
//    return Errno;
//  }
//  Off = (Rootdir - (Dataregion << Sectorshift));
//  Fclust = (Shr__(Off, (Clustershift + Sectorshift)));
//  Floc = (Off - (Fclust << (Clustershift + Sectorshift)));
//  Frem = (Rootdirend - Rootdir);
//  Filesize = (Floc + Frem);
//  return 0;
//}

// TODO(SRLM): UNTESTED
//int SecureDigitalCard::Nextfile(char * Fbuf)
//{
//  int32_t	I, T, At, Lns;
//  int32_t result = 0;
//  while (1) {
//    if (Bufat >= Bufend) {
//      T = Pfillbuf();
//      if (T < 0) {
//        return T;
//      }
//      if (((Shr__(Floc, Sectorshift)) & ((1 << Clustershift) - 1)) == 0) {
//        (Fclust++);
//      }
//    }
//    At = ((int32_t)(&Buf) + Bufat);
//    if (((uint8_t *)At)[0] == 0) {
//      return (-1);
//    }
//    Bufat = (Bufat + Dirsize);
//    if ((((uint8_t *)At)[0] != 229) && ((((uint8_t *)At)[11] & 0x18) == 0)) {
//      Lns = Fbuf;
//      I = 0;
//      do {
//        ((uint8_t *)Fbuf)[0] = ((uint8_t *)At)[I];
//        (Fbuf++);
//        if (((uint8_t *)At)[I] != ' ') {
//          Lns = Fbuf;
//        }
//        if ((I == 7) || (I == 10)) {
//          Fbuf = Lns;
//          if (I == 7) {
//            ((uint8_t *)Fbuf)[0] = '.';
//            (Fbuf++);
//          }
//        }
//        I = (I + 1);
//      } while (I <= 10);
//      ((uint8_t *)Fbuf)[0] = 0;
//      return 0;
//    }
//  }
//  return result;
//}

int SecureDigitalCard::GetClusterSize(void)
{
  return Clustersize;
}

int SecureDigitalCard::GetClusterCount(void)
{
  return Totclusters;
}

