//
// automatically generated by spin2cpp v1.01 on Wed Dec 12 21:35:05 2012
// spin2cpp.linux --main test_nl.spin 
//

//TODO(SRLM): Warning: the Read_slow function has a Crash call, but nowhere else
//is the Read_slow function, when called, enclosed by a test to check for the
//negative return value. Every time that it is called needs something like:
// int errno = Read_slow(...)
// if(errno < 0)
// 	return errno;

#include <propeller.h>
#include "sdsafespi.h"

#include <stdio.h>

#ifdef __GNUC__
#define INLINE__ static inline
#define Yield__() __asm__ volatile( "" ::: "memory" )
#define PostEffect__(X, Y) __extension__({ int32_t tmp__ = (X); (X) = (Y); tmp__; })
#else
#define INLINE__ static
static int32_t tmp__;
#define PostEffect__(X, Y) (tmp__ = (X), (X) = (Y), tmp__)
#define Yield__()
#endif

INLINE__ int32_t Shr__(uint32_t a, uint32_t b) { return (a>>b); }
volatile uint8_t SdSafeSPI::dat[] = {
  0x2f, 0xf1, 0xbf, 0xa0, 0x31, 0xf3, 0xbf, 0xa0, 0x2b, 0xed, 0xbf, 0xa0, 0x01, 0x80, 0xfe, 0xa4, 
  0xf0, 0x81, 0x3e, 0x08, 0xf1, 0x8b, 0xbe, 0xa0, 0xa4, 0x66, 0xfd, 0x5c, 0xf0, 0x81, 0xbe, 0x08, 
  0x00, 0x80, 0x7e, 0xc3, 0x06, 0x00, 0x78, 0x5c, 0x72, 0x80, 0x7e, 0x86, 0x1d, 0x00, 0x68, 0x5c, 
  0x77, 0x80, 0x7e, 0x86, 0x2d, 0x00, 0x68, 0x5c, 0x7a, 0x80, 0x7e, 0x86, 0x16, 0x00, 0x68, 0x5c, 
  0x74, 0x80, 0x7e, 0x86, 0x2e, 0x6f, 0x2a, 0x08, 0x2d, 0x71, 0x2a, 0x08, 0x00, 0x80, 0xfe, 0xa0, 
  0xf0, 0x81, 0x3e, 0x08, 0x06, 0x00, 0x7c, 0x5c, 0x7a, 0x82, 0xfe, 0xa0, 0x01, 0x76, 0xfe, 0xa4, 
  0x01, 0x84, 0xfe, 0xa4, 0x35, 0x96, 0xfc, 0x5c, 0x41, 0x81, 0xbe, 0xa0, 0xf0, 0x81, 0x3e, 0x08, 
  0x06, 0x00, 0x7c, 0x5c, 0x2e, 0x85, 0xbe, 0x08, 0x42, 0x7f, 0xbe, 0xa0, 0x01, 0x7e, 0xfe, 0x80, 
  0x3b, 0x7f, 0x3e, 0x86, 0x72, 0x78, 0x6a, 0x86, 0x25, 0x00, 0x68, 0x5c, 0x72, 0x82, 0xfe, 0xa0, 
  0x35, 0x96, 0xfc, 0x5c, 0x10, 0x78, 0xfd, 0x58, 0xb4, 0x8a, 0xfd, 0x5c, 0x41, 0x81, 0xbe, 0xa0, 
  0xf0, 0x81, 0x3e, 0x08, 0x72, 0x82, 0xfe, 0xa0, 0x01, 0x84, 0xfe, 0x80, 0x35, 0x96, 0xfc, 0x5c, 
  0x06, 0x00, 0x7c, 0x5c, 0x2e, 0x85, 0xbe, 0x08, 0x11, 0x78, 0xfd, 0x58, 0xb4, 0x8a, 0xfd, 0x5c, 
  0x41, 0x81, 0xbe, 0xa0, 0xf0, 0x81, 0x3e, 0x08, 0x77, 0x82, 0xfe, 0xa0, 0x35, 0x96, 0xfc, 0x5c, 
  0x06, 0x00, 0x7c, 0x5c, 0x42, 0x77, 0x3e, 0x86, 0x3c, 0x83, 0x2a, 0x86, 0x42, 0x00, 0x68, 0x5c, 
  0x77, 0x78, 0x7e, 0x86, 0x5a, 0xc4, 0xe8, 0x5c, 0x72, 0x78, 0x7e, 0x86, 0x53, 0xac, 0xe8, 0x5c, 
  0x77, 0x82, 0x7e, 0x86, 0x57, 0xb2, 0xe8, 0x5c, 0x72, 0x82, 0x7e, 0x86, 0x50, 0xa4, 0xe8, 0x5c, 
  0x7a, 0x82, 0x7e, 0x86, 0x4c, 0x9e, 0xe8, 0x5c, 0x42, 0x77, 0xbe, 0xa0, 0x01, 0x76, 0xfe, 0x80, 
  0x41, 0x79, 0xbe, 0xa0, 0x77, 0x82, 0x7e, 0x86, 0xf0, 0x48, 0xea, 0x5c, 0x72, 0x82, 0x7e, 0x86, 
  0xc6, 0xde, 0xe9, 0x5c, 0x7a, 0x82, 0x7e, 0x86, 0x00, 0x82, 0xea, 0xa0, 0x00, 0x00, 0x7c, 0x5c, 
  0x2a, 0xe9, 0xbf, 0x68, 0x8d, 0x46, 0xfd, 0x5c, 0x8d, 0x46, 0xfd, 0x5c, 0x00, 0x00, 0x7c, 0x5c, 
  0xa4, 0x86, 0xfe, 0x58, 0x63, 0xf6, 0xfc, 0x5c, 0x00, 0x00, 0x7c, 0x5c, 0x98, 0x86, 0xfe, 0x58, 
  0x63, 0xf6, 0xfc, 0x5c, 0x7c, 0x00, 0xfd, 0x5c, 0x00, 0x00, 0x7c, 0x5c, 0xb2, 0x86, 0xfe, 0x58, 
  0x63, 0xf6, 0xfc, 0x5c, 0x00, 0x00, 0x7c, 0x5c, 0x7c, 0x00, 0xfd, 0x5c, 0x10, 0x7e, 0xfe, 0xa0, 
  0x8d, 0x46, 0xfd, 0x5c, 0x5c, 0x7e, 0xfe, 0xe4, 0xfa, 0xf9, 0xff, 0x58, 0x81, 0x18, 0xfd, 0x5c, 
  0x8d, 0x46, 0xfd, 0x5c, 0x7c, 0x00, 0xfd, 0x5c, 0x00, 0x00, 0x7c, 0x5c, 0x2b, 0xed, 0xbf, 0xa0, 
  0x2a, 0xe9, 0xbf, 0x68, 0x2a, 0xe9, 0xbf, 0x64, 0x8d, 0x46, 0xfd, 0x5c, 0x43, 0xf9, 0xbf, 0xa0, 
  0x81, 0x18, 0xfd, 0x5c, 0x42, 0xf9, 0xbf, 0xa0, 0x2c, 0xf9, 0xbf, 0x2c, 0x81, 0x18, 0xfd, 0x5c, 
  0x01, 0xf8, 0xff, 0x24, 0x81, 0x18, 0xfd, 0x5c, 0x01, 0xf8, 0xff, 0x24, 0x81, 0x18, 0xfd, 0x5c, 
  0x01, 0xf8, 0xff, 0x24, 0x81, 0x18, 0xfd, 0x5c, 0x8d, 0x46, 0xfd, 0x5c, 0x18, 0x86, 0xfe, 0x28, 
  0x4c, 0x86, 0x7e, 0x86, 0x8d, 0x46, 0xe9, 0x5c, 0x09, 0x7e, 0xfe, 0xa0, 0x8d, 0x46, 0xfd, 0x5c, 
  0x80, 0x7c, 0x7e, 0x63, 0x77, 0x7e, 0xf2, 0xe4, 0x3e, 0x83, 0x96, 0xa4, 0x00, 0x00, 0x7c, 0x5c, 
  0x30, 0x7f, 0xbe, 0xa0, 0x8d, 0x46, 0xfd, 0x5c, 0xff, 0x7c, 0x7e, 0x86, 0x7d, 0x7e, 0xd6, 0xe4, 
  0x00, 0x00, 0x7c, 0x5c, 0x29, 0xe9, 0xbf, 0x64, 0x00, 0xfa, 0xff, 0xa0, 0x80, 0xf6, 0xff, 0x58, 
  0x01, 0xf8, 0xff, 0x24, 0x01, 0xf8, 0xff, 0x24, 0x01, 0xf8, 0xff, 0x24, 0x01, 0xf8, 0xff, 0x24, 
  0x01, 0xf8, 0xff, 0x24, 0x01, 0xf8, 0xff, 0x24, 0x01, 0xf8, 0xff, 0x24, 0x00, 0xf6, 0xff, 0xa0, 
  0x00, 0x00, 0x7c, 0x5c, 0x01, 0xf8, 0xff, 0xa4, 0x00, 0x7c, 0xfe, 0xa0, 0xc0, 0xfa, 0xff, 0x58, 
  0x40, 0xf6, 0xff, 0x58, 0xf2, 0x51, 0x3e, 0x61, 0x01, 0x7c, 0xfe, 0x34, 0xf2, 0x51, 0x3e, 0x61, 
  0x01, 0x7c, 0xfe, 0x34, 0xf2, 0x51, 0x3e, 0x61, 0x01, 0x7c, 0xfe, 0x34, 0xf2, 0x51, 0x3e, 0x61, 
  0x01, 0x7c, 0xfe, 0x34, 0xf2, 0x51, 0x3e, 0x61, 0x01, 0x7c, 0xfe, 0x34, 0xf2, 0x51, 0x3e, 0x61, 
  0x01, 0x7c, 0xfe, 0x34, 0xf2, 0x51, 0x3e, 0x61, 0x01, 0x7c, 0xfe, 0x34, 0xf2, 0x51, 0x3e, 0x61, 
  0x00, 0xf6, 0xff, 0xa0, 0x01, 0x7c, 0xfe, 0x34, 0x00, 0xf8, 0xff, 0xa0, 0x00, 0x00, 0x7c, 0x5c, 
  0xf1, 0x7f, 0xbe, 0xa0, 0x3f, 0x73, 0xbe, 0x80, 0x45, 0x73, 0xbe, 0x84, 0x3f, 0x71, 0xbe, 0x80, 
  0x45, 0x71, 0xbe, 0x84, 0x3f, 0x8b, 0xbe, 0xa0, 0x00, 0x7e, 0xfe, 0x08, 0x3f, 0x71, 0xbe, 0xe1, 
  0x00, 0x6e, 0xfe, 0xc8, 0x3a, 0x73, 0x3e, 0x87, 0xb3, 0x00, 0x70, 0x5c, 0x7a, 0x82, 0xfe, 0xa0, 
  0x01, 0x76, 0xfe, 0xa4, 0x01, 0x84, 0xfe, 0xa4, 0x35, 0x96, 0xfc, 0x5c, 0x00, 0x00, 0x7c, 0x5c, 
  0x32, 0xf3, 0xbf, 0xa0, 0x01, 0xf6, 0xff, 0xa0, 0x2d, 0x89, 0xbe, 0x08, 0x04, 0x7a, 0xfe, 0xa0, 
  0x46, 0x79, 0xfd, 0x54, 0x3f, 0x7f, 0xbe, 0x08, 0x20, 0x7e, 0xfe, 0xa0, 0x44, 0xfb, 0xbf, 0xa0, 
  0xfd, 0x01, 0xbc, 0x08, 0x35, 0x79, 0xbd, 0x80, 0xbc, 0x7e, 0xfe, 0xe4, 0x36, 0x79, 0xbd, 0x84, 
  0x04, 0x88, 0xfe, 0x80, 0xb9, 0x7a, 0xfe, 0xe4, 0x00, 0xf6, 0xff, 0xa0, 0x00, 0xfa, 0xff, 0xa0, 
  0x31, 0xf3, 0xbf, 0xa0, 0x00, 0x00, 0x7c, 0x5c, 0x46, 0xcd, 0xfd, 0x54, 0x80, 0x7a, 0xfe, 0xa0, 
  0x30, 0x7f, 0xbe, 0xa0, 0x8d, 0x46, 0xfd, 0x5c, 0xfe, 0x7c, 0x7e, 0x86, 0xc9, 0x7e, 0xd6, 0xe4, 
  0x64, 0x82, 0xd6, 0xa4, 0xef, 0x00, 0x54, 0x5c, 0x01, 0xf8, 0xff, 0xa4, 0x80, 0x7a, 0xfe, 0xa0, 
  0x04, 0x7e, 0xfe, 0xa0, 0xc0, 0xfa, 0xff, 0x58, 0x40, 0xf6, 0xff, 0x58, 0xf2, 0x51, 0x3e, 0x61, 
  0x08, 0x7c, 0xfe, 0x34, 0xf2, 0x51, 0x3e, 0x61, 0x02, 0x7c, 0xfe, 0x70, 0xf2, 0x51, 0x3e, 0x61, 
  0x04, 0x7c, 0xfe, 0x70, 0xf2, 0x51, 0x3e, 0x61, 0x08, 0x7c, 0xfe, 0x70, 0xf2, 0x51, 0x3e, 0x61, 
  0x10, 0x7c, 0xfe, 0x70, 0xf2, 0x51, 0x3e, 0x61, 0x20, 0x7c, 0xfe, 0x70, 0xf2, 0x51, 0x3e, 0x61, 
  0x40, 0x7c, 0xfe, 0x70, 0xf2, 0x51, 0x3e, 0x61, 0x00, 0xf6, 0xff, 0xa0, 0x80, 0x7c, 0xfe, 0x70, 
  0xd2, 0x7e, 0xfe, 0xe4, 0x00, 0x7c, 0xfe, 0x3c, 0x3e, 0x01, 0xbc, 0xa0, 0x33, 0xcd, 0xbd, 0x80, 
  0xd0, 0x7a, 0xfe, 0xe4, 0x00, 0xf8, 0xff, 0xa0, 0x8d, 0x46, 0xfd, 0x5c, 0x8d, 0x46, 0xfd, 0x5c, 
  0x8d, 0x46, 0xfd, 0x5c, 0x00, 0x72, 0xfe, 0xa0, 0x00, 0x82, 0xfe, 0xa0, 0x00, 0x00, 0x7c, 0x5c, 
  0x46, 0xed, 0xfd, 0x50, 0x80, 0x7a, 0xfe, 0xa0, 0x7c, 0x00, 0xfd, 0x5c, 0xf8, 0xf9, 0xff, 0x58, 
  0x81, 0x18, 0xfd, 0x5c, 0x00, 0xfa, 0xff, 0xa0, 0x46, 0xf9, 0xbf, 0xa0, 0x01, 0xec, 0xfd, 0x80, 
  0x18, 0xf8, 0xff, 0x24, 0x80, 0xf6, 0xff, 0x58, 0x01, 0xf8, 0xff, 0x24, 0x01, 0xf8, 0xff, 0x24, 
  0x01, 0xf8, 0xff, 0x24, 0x01, 0xf8, 0xff, 0x24, 0x01, 0xf8, 0xff, 0x24, 0x01, 0xf8, 0xff, 0x24, 
  0x01, 0xf8, 0xff, 0x24, 0x11, 0xf8, 0xff, 0x24, 0x01, 0xf8, 0xff, 0x24, 0x01, 0xf8, 0xff, 0x24, 
  0x01, 0xf8, 0xff, 0x24, 0x01, 0xf8, 0xff, 0x24, 0x01, 0xf8, 0xff, 0x24, 0x01, 0xf8, 0xff, 0x24, 
  0x01, 0xf8, 0xff, 0x24, 0x11, 0xf8, 0xff, 0x24, 0x01, 0xf8, 0xff, 0x24, 0x01, 0xf8, 0xff, 0x24, 
  0x01, 0xf8, 0xff, 0x24, 0x01, 0xf8, 0xff, 0x24, 0x01, 0xf8, 0xff, 0x24, 0x01, 0xf8, 0xff, 0x24, 
  0x01, 0xf8, 0xff, 0x24, 0x11, 0xf8, 0xff, 0x24, 0x01, 0xf8, 0xff, 0x24, 0x01, 0xf8, 0xff, 0x24, 
  0x01, 0xf8, 0xff, 0x24, 0x01, 0xf8, 0xff, 0x24, 0x01, 0xf8, 0xff, 0x24, 0x01, 0xf8, 0xff, 0x24, 
  0x01, 0xf8, 0xff, 0x24, 0x00, 0xf6, 0xff, 0xa0, 0xf6, 0x7a, 0xfe, 0xe4, 0x8d, 0x46, 0xfd, 0x5c, 
  0x8d, 0x46, 0xfd, 0x5c, 0x8d, 0x46, 0xfd, 0x5c, 0x1f, 0x7c, 0xfe, 0x60, 0x05, 0x7c, 0x7e, 0x86, 
  0x00, 0x82, 0xea, 0xa0, 0x65, 0x82, 0xd6, 0xa4, 0x8d, 0x46, 0xfd, 0x5c, 0x00, 0x72, 0xfe, 0xa0, 
  0x00, 0x00, 0x7c, 0x5c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x40, 0x42, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x02, 0x00, 0x00, 
  0x00, 0x04, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 
  0x00, 0x00, 0x00, 0x00, 
};
int32_t SdSafeSPI::Start(int32_t Basepin)
{
  return Start_explicit(Basepin, (Basepin + 1), (Basepin + 2), (Basepin + 3));
}

int32_t SdSafeSPI::Readblock(int32_t Block_index, char * Buffer_address)
{
  int32_t result = 0;
  if (Spi_engine_cog == 0) {
    return Err_spi_engine_not_running;
  }
  if ((int)Buffer_address & 0x3) {
    return Err_block_not_long_aligned;
  }
  Spi_block_index = Block_index;
  Spi_buffer_address = Buffer_address;
  Spi_command = 'r';
  while (Spi_command == 'r') {
    Yield__();
  }
  if (Spi_command < 0) {
    return Spi_command;
  }
  return result;
}

int32_t SdSafeSPI::Writeblock(int32_t Block_index, char * Buffer_address)
{
  int32_t result = 0;
  if (Spi_engine_cog == 0) {
    return Err_spi_engine_not_running;
  }
  if ((int)Buffer_address & 0x3) {
    return Err_block_not_long_aligned;
  }
  Spi_block_index = Block_index;
  Spi_buffer_address = Buffer_address;
  Spi_command = 'w';
  while (Spi_command == 'w') {
    Yield__();
  }
  if (Spi_command < 0) {
    return Spi_command;
  }
  return result;
}

int32_t SdSafeSPI::Get_seconds(void)
{
  if (Spi_engine_cog == 0) {
    return Err_spi_engine_not_running;
  }
  Spi_command = 't';
  while (Spi_command == 't') {
    Yield__();
  }
  return Spi_block_index;
}

int32_t SdSafeSPI::Get_milliseconds(void)
{
  int32_t Ms = 0;
  if (Spi_engine_cog == 0) {
    return Err_spi_engine_not_running;
  }
  Spi_command = 't';
  while (Spi_command == 't') {
    Yield__();
  }
  Ms = (Spi_block_index * 1000);
  Ms = (Ms + (((int)Spi_buffer_address * 1000) / CLKFREQ));
  return Ms;
}

int32_t SdSafeSPI::Start_explicit(int32_t Do, int32_t Clk, int32_t Di, int32_t Cs)
{
  int32_t	Tmp, I;
  int32_t Card_type = 0;

  Stop();

  waitcnt(((500 + (Shr__(CLKFREQ, 8))) + CNT));
  ((int32_t *)&dat[1172])[0] = Do;
  ((int32_t *)&dat[1184])[0] = ((1<<Do));
  ((int32_t *)&dat[1176])[0] = Clk;
  ((int32_t *)&dat[1180])[0] = Di;
  ((int32_t *)&dat[1188])[0] = ((1<<Di));
  ((int32_t *)&dat[1192])[0] = ((1<<Cs));
  ((int32_t *)&dat[1200])[0] = 9;
  ((int32_t *)&dat[1196])[0] = (((*(int32_t *)&dat[1192]) | ((1<<(*(int32_t *)&dat[1176])))) | (*(int32_t *)&dat[1188]));
  DIRA = (DIRA | (*(int32_t *)&dat[1196]));
  OUTA = (OUTA | (*(int32_t *)&dat[1196]));

  {
    int32_t _idx__0020;
    _idx__0020 = 4096;
    do {
      OUTA = ((OUTA & (~(1 << Clk))) | (1 << Clk));
      OUTA &= ~(1<<Clk);
      _idx__0020 = (_idx__0020 + -1);
    } while (_idx__0020 >= 1);
  }

  Spi_block_index = CNT;
  Tmp = 0;
  I = 0;
  do {
    if (Tmp != 1) {
      Tmp = Send_cmd_slow(Cmd0, 0, 149);
      if (Tmp & 0x4) {
        if (I & 0x1) {
          {
            int32_t _idx__0021;
            _idx__0021 = 4;
            do {
              Read_32_slow();
              _idx__0021 = (_idx__0021 + -1);
            } while (_idx__0021 >= 1);
          }
          Send_slow(253, 8);
          Read_32_slow();
          while (Read_slow() != 255) {
            Yield__();
          }
        } else {
          Send_cmd_slow(Cmd12, 0, 97);
        }
      }
    }
    I = (I + 1);
  } while (I <= 9);
  if (Tmp != 1) {
    return Crash(Err_card_not_reset);
  }
  if (Send_cmd_slow(Cmd8, 426, 135) == 1) {
    Tmp = Read_32_slow();

    if ((Tmp & 0x1ff) != 426) {
      return Crash(Err_3v3_not_supported);
    }

    while (Send_cmd_slow(Acmd41, ((1<<30)), 119)) {
      Yield__();
    }
    if (Send_cmd_slow(Cmd58, 0, 253) != 0) {
      return Crash(Err_ocr_failed);
    }
    Tmp = Read_32_slow();

    if (Tmp & 0x40000000) {
      Card_type = Type_sdhc;
      ((int32_t *)&dat[1200])[0] = 0;
    } else {
      Card_type = Type_sd;
    }
  } else {

    if (Send_cmd_slow(Acmd41, 0, 229) < 2) {
      Card_type = Type_sd;
      while (Send_cmd_slow(Acmd41, 0, 229)) {
        Yield__();
      }
    } else {
      Card_type = Type_mmc;
      while (Send_cmd_slow(Cmd1, 0, 249)) {
        Yield__();
      }
    }
    Send_cmd_slow(Cmd16, 512, 21);
  }

  Send_cmd_slow(Cmd59, 0, 145);
  OUTA = (OUTA | (*(int32_t *)&dat[1192]));
  ((int32_t *)&dat[1212])[0] = (0x10000000 | (Di << 0));
  ((int32_t *)&dat[1220])[0] = (0x10000000 | (Clk << 0));
  ((int32_t *)&dat[1216])[0] = (Shr__(CLKFREQ, 0x6));
  ((int32_t *)&dat[1256])[0] = 125;
  ((int32_t *)&dat[1256])[0] = (CLKFREQ / (1000 / (*(int32_t *)&dat[1256])));
  ((int32_t *)&dat[1204])[0] = (int32_t)(&Spi_buffer_address);
  ((int32_t *)&dat[1208])[0] = (int32_t)(&Spi_block_index);
  Spi_command = 0;

  Spi_engine_cog = (cognew((int32_t)(&(*(int32_t *)&dat[0])), (int32_t)(&Spi_command)) + 1);

  if (Spi_engine_cog == 0) {
    return Crash(Err_spi_engine_not_running);
  }

  while (Spi_command != (-1)) {
    Yield__();
  }

  DIRA = (DIRA & (~(*(int32_t *)&dat[1196])));
  return Card_type;
}

int32_t SdSafeSPI::Release(void)
{
  int32_t result = 0;
  if (Spi_engine_cog) {
    Spi_command = 'z';
    while (Spi_command == 'z') {
      Yield__();
    }
  }
  return result;
}

int32_t SdSafeSPI::Stop(void)
{
  int32_t result = 0;
  Release();
  if (Spi_engine_cog) {
    cogstop((PostEffect__(Spi_engine_cog, 0) - 1));
  }
  return result;
}

int32_t SdSafeSPI::Crash(int32_t Abort_code)
{
  DIRA = (DIRA & (~(*(int32_t *)&dat[1196])));
  return Abort_code;
}

int32_t SdSafeSPI::Send_cmd_slow(int32_t Cmd, int32_t Val, int32_t Crc)
{
  int32_t	Time_stamp;
  int32_t Reply = 0;
  if (Cmd & 0x80) {
    Cmd = (Cmd & 0x7f);
    Reply = Send_cmd_slow(Cmd55, 0, 101);
    if (Reply > 1) {
      return Reply;
    }
  }
  OUTA = (OUTA | (*(int32_t *)&dat[1192]));
  OUTA = (OUTA & (~(*(int32_t *)&dat[1192])));
  Read_32_slow();
  Send_slow(Cmd, 8);
  Send_slow(Val, 32);
  Send_slow(Crc, 8);
  if (Cmd == Cmd12) {
    Read_slow();
  }
  Time_stamp = 9;
  do {
    Reply = Read_slow();
  } while ((Reply & 0x80) && (Time_stamp--));
  return Reply;
}

int32_t SdSafeSPI::Send_slow(int32_t Value, int32_t Bits_to_send)
{
  int32_t result = 0;
  Value = (__builtin_propeller_rev(Value, 32 - Bits_to_send));
  {
    int32_t _idx__0022;
    _idx__0022 = Bits_to_send;
    do {
      OUTA &= ~(1<<(*(int32_t *)&dat[1176]));
      OUTA = ((OUTA & (~(1 << (*(int32_t *)&dat[1180])))) | ((Value & 0x1) << (*(int32_t *)&dat[1180])));
      Value = (Shr__(Value, 1));
      OUTA = ((OUTA & (~(1 << (*(int32_t *)&dat[1176])))) | (1 << (*(int32_t *)&dat[1176])));
      _idx__0022 = (_idx__0022 + -1);
    } while (_idx__0022 >= 1);
  }
  return result;
}

int32_t SdSafeSPI::Read_32_slow(void)
{
  int32_t R = 0;
  {
    int32_t _idx__0023;
    _idx__0023 = 4;
    do {
      R = (R << 8);
      R = (R | Read_slow());
      _idx__0023 = (_idx__0023 + -1);
    } while (_idx__0023 >= 1);
  }
  return R;
}

int32_t SdSafeSPI::Read_slow(void)
{
  int32_t R = 0;
  OUTA = ((OUTA & (~(1 << (*(int32_t *)&dat[1180])))) | (1 << (*(int32_t *)&dat[1180])));
  {
    int32_t _idx__0024;
    _idx__0024 = 8;
    do {
      OUTA &= ~(1<<(*(int32_t *)&dat[1176]));
      OUTA = ((OUTA & (~(1 << (*(int32_t *)&dat[1176])))) | (1 << (*(int32_t *)&dat[1176])));
      R = (R + (R + ((INA >> (*(int32_t *)&dat[1172])) & 0x1)));
      _idx__0024 = (_idx__0024 + -1);
    } while (_idx__0024 >= 1);
  }
  if ((CNT - Spi_block_index) > (CLKFREQ << 2)) {
    return Crash(Err_card_busy_timeout);
  }
  return R;
}

