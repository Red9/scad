//
// automatically generated by spin2cpp v1.01 on Wed Dec 12 21:35:05 2012
// spin2cpp.linux --main test_nl.spin 
//

//TODO(SRLM): Mount_explicit seems to hang when there is no card in the slot.


//TODO(SRLM): I can change the PutX and GetX functions to just the prefix, and
// overload the operators instead of having a unique function name.

//TODO(SRLM): I think the functions with buffer in them should have "volatile"
//in the function declaration (since the buffer can be modified by PASM).

//TODO(SRLM): I should add a unit test or something for the "no SD card" condition...
// At this time, it should return -1 (and *not* hang/freeze).

//FSRW questions:
//

/*
Cluster size: If it's not 32768, it should be (32K
clusters). To format a drive with FAT32 with 32K clusters, use the following
command under linux:

sudo mkdosfs /dev/sdX -s 64 -F 32 -I

Note: the mkdosfs command will format the entire disk, and erase all information on it.
*/

#ifndef fsrwSpin_Class_Defined__
#define fsrwSpin_Class_Defined__

#include <stdint.h>
#include "sdsafespi.h"

class SecureDigitalCard {
public:
  static const int Sectorsize = 512;
  static const int Sectorshift = 9;
  static const int Dirsize = 32;
  static const int Dirshift = 5;
  SdSafeSPI	Sdspi;

/*
  Mounts a volume. Closes any open files (if this is a remount). Requires a cog
  for the SD SPI driver.
  
  Pins must be in the following order, from basepin up:
  Basepin +0: DO
  Basepin +1: CLK
  Basepin +2: DI
  Basepin +3: CS
  
   Return Values:
   0:    Success.
   -1:   card not reset (usually means no card detected)
   -2:   3.3v not supported (?)
   -3:   OCR failed (?)
   -4:   block not long aligned (SdSafeSPI)
   ...
   -20:  not a FAT16 or FAT32 volume
   -21:  bad bytes per sector
   -22:  bad sectors per cluster
   -23:  not two FATs (what does this mean?)
   -24:  bad FAT signature
   ...
   -512: Buf and Buf2 not longword aligned (was the class data members modified?)
   -999: No card detected
*/
  int	Mount(int Basepin);

/*  
  Mount a volume with explicit pin numbers. Does not require adjacent pins.
  See Mount(int Basepin) for more information.
*/
  int	Mount(int DO, int CLK, int DI, int CS);

/*
Closes any open files, and unmounts the SD card. Frees a cog.
*/
  int	Unmount(void);
  
/*
Close any currently open file, and open a new one with the given
file name and mode.  Mode can be 'r' 'w' 'a' or 'd' (delete).  If the
file did not exist, and the mode was not "w" or "a", -1 will be
returned.  Otherwise abort will be called with a negative error
code.

If the file is successfully opened then the current file size in bytes will be
returned.

Filename is in 8.3 format. If it's shorter, then it will be padded (TODO(SRLM): padded with what?). The filename
will also be converted to uppercase.

If the mode is 'd', and the file exists, a 0 will be returned. If the file
doesn't exist, then a -1 will be returned.

If the mode is 'a', and the file exists, a ??? will be returned. If the file
doesn't exist, then a -1 will be returned.
*/
  int	Open(const char * Filename, const char Mode);
  
/*
Flush and close the currently open file if any.  Also reset the
 pointers to valid values.  If there is no error, 0 will be returned.
 Also, releases the SD pins to tristate. 
*/
  int	Close(void);
  



/*
Read count bytes into the buffer ubuf.  Returns the number of bytes
successfully read, or a negative number if there is an error.

If you try to read past the end of a file, then the remaining bytes will be put
into the buffer, and a -1 will be returned (Note: the number of bytes read is
NOT returned in this case).

The buffer may be as large as you want.
*/
  int	Get(char * Ubuf, int Count);
  
/*
Read and return a single character.  If the end of file is
  reached, -1 will be returned.  If an error occurs, a negative
  number will be returned.
*/
  int	Get(void);
  
//TODO(SRLM): Write a function that gets a string:
//  int   Get(char * Ubuf, char EndOfStringChar);


/*
Write count bytes from the buffer ubuf.  Returns the number of bytes
 successfully written, or a negative number if there is an error.
 The buffer may be as large as you want.
TODO(SRLM): WARNING: does not check to make sure that a file is actually open...
*/
  int	Put(const char * Ubuf, int Count);
  
/*
  Write a null-terminated string to the file. Does not write the trailing 0. The
  string may be as large as you want.
  
  returns the number of bytes successfully written, or a negative number if
  there is an error.
TODO(SRLM): WARNING: does not check to make sure that a file is actually open...
*/
  int	Put(const char * B);
  
/*
Write a single character into the file open for write.  Returns
 0 if successful, or a negative number if some error occurred.
 
TODO(SRLM): WARNING: does not check to make sure that a file is actually open...
*/
  int	Put(const char C);

/*
Set the current date and time, as a long, in the format
 required by FAT16.  Various limits are not checked.
 
TODO(SRLM): What does it do with this date? Does it store it as read/write/modify date?
 
 Returns the FAT16 date format (you can safely ignore the return in all cases,
 unless you want to test the correctness of the function).
*/
  int	SetDate(int Year, int Month, int Day, int Hour, int Minute, int Second);

/*
Seek during read mode to number of bytes specified from the begining of the
file. Returns -1 on failure (such as seeking during write).
*/
  int	Seek(int position);

/*
Close the currently open file, and set up the read buffer for
   calls to nextfile().
   Returns negative on error (only occurs if there is an error closing the file).
 TODO(SRLM): UNTESTED
*/
//  int	Opendir(void);
  
/*
Find the next file in the root directory and extract its
 (8.3) name into fbuf.  Fbuf must be sized to hold at least
 13 characters (8 + 1 + 3 + 1).  If there is no next file,
 -1 will be returned.  If there is, 0 will be returned.
 
 TODO(SRLM): UNTESTED
*/
//  int	Nextfile(char * Fbuf);
  
  
/*
Returns the size of the cluster, in bytes.
*/
  int	GetClusterSize(void);
  
/*
Returns the cluster count. What does this mean? I (SRLM) don't know. I also don't 
know how to test it, so it is not tested.
*/
  int	GetClusterCount(void);
  
private:
  int32_t	Fclust;
  int32_t	Filesize;
  int32_t	Floc;
  int32_t	Frem;
  int32_t	Bufat;
  int32_t	Bufend;
  int32_t	Direntry;
  int32_t	Writelink;
  int32_t	Fatptr;
  int32_t	Firstcluster;
  int32_t	Errno;
  int32_t	Filesystem;
  int32_t	Rootdir;
  int32_t	Rootdirend;
  int32_t	Dataregion;
  int32_t	Clustershift;
  int32_t	Clustersize;
  int32_t	Fat1;
  int32_t	Totclusters;
  int32_t	Sectorsperfat;
  int32_t	Endofchain;
  int32_t	Pdate;
  int32_t	Lastread;
  int32_t	Dirty;
  
/*
  Buffering:  two sector buffers.  These two buffers must be longword
  aligned!  To ensure this, make sure they are the first byte variables
  defined in this object.
*/
  uint8_t	volatile Buf[512];
  uint8_t	volatile Buf2[512];
  uint8_t	Padname[11];
  
/*
On metadata writes, if we are updating the FAT region, also update
 the second FAT region.
 
 Returns negative error or 0 for success
*/
  int	Writeblock2(int N, char * B);
  int32_t	Flushifdirty(void);
  int32_t	Readblockc(int32_t N);
  
  
  
/*
Read a byte-reversed word from a (possibly odd) address.
*/
  int	Brword(char * b);
  
/*
Read a byte-reversed long from a (possibly odd) address.
*/
  int	Brlong(char * b);

/*
Read a cluster entry.
*/
  int	Brclust(char * B);
  
/*
Write a byte-reversed word to a (possibly odd) address, and
  mark the metadata buffer as dirty.
*/
  void	Brwword(char * w, int v);
  
/*
Write a byte-reversed long to a (possibly odd) address, and
 mark the metadata buffer as dirty.
*/
  void	Brwlong(char * w, int v);
  
/*
 Write a cluster entry.
*/
  void	Brwclust(char * w, int v);
  int	Getfstype(void);
  
/*
Read a byte address from the disk through the metadata buffer and
 return a pointer to that location.
*/
  char *	Readbytec(int32_t Byteloc);
  
/*
Read a fat location and return a pointer to the location of that
 entry.
*/
  char *	Readfat(int32_t Clust);
  
/*
Follow the fat chain and update the writelink.
*/
  int32_t	Followchain(void);
  
  int32_t	Nextcluster(void);
  
/*
Free an entire cluster chain.  Used by remove and by overwrite.
  Assumes the pointer has already been cleared/set to end of chain.
*/
  int32_t	Freeclusters(int32_t Clust);

/*
This is just a pass-through function to allow the block layer
 to tristate the I/O pins to the card.
*/
  void	Release(void);
  
  int32_t	Datablock(void);
  int32_t	Uc(int32_t C);
  int32_t	Pflushbuf(int32_t Rcnt, int32_t Metadata);
  int32_t	Pflush(void);
  int32_t	Pfillbuf(void);
};

#endif
