//
// automatically generated by spin2cpp v1.02 on Sat Dec 29 22:32:12 2012
// spin2cpp.linux serial.spin 
//

#include <stdio.h>

#include <propeller.h>
#include "serial.h"


#ifdef __GNUC__
#define INLINE__ static inline
#else
#define INLINE__ static
#endif

INLINE__ int32_t Max__(int32_t a, int32_t b) { return a > b ? a : b; }
INLINE__ int32_t Shr__(uint32_t a, uint32_t b) { return (a>>b); }

extern uint8_t _load_start_serial_cog[];


void SetDriverLong(int index, int value){
    ((int32_t *)&_load_start_serial_cog[index])[0] = value;
}

/* Warning: SetDriverLong(char **, int) must be declared second, otherwise it calls itself! */
void SetDriverLong(char ** index, int value){
    SetDriverLong((int)index, value);
}



bool Serial::Start(int Rx_pin, int Tx_pin, int Rate, int ctspin)
{
    volatile void * reference = NULL;
    __asm__ volatile ("mov %[reference], #Fds_entry \n\t" : [reference] "+r" (reference) );

  Stop();

  extern char * Masktx asm("Masktx");
  extern char * Maskrx asm("Maskrx");
  extern char * Ctra_val asm("Ctra_val");
  extern char * Ctrb_val asm("Ctrb_val");
  extern char * Period_ptr asm("Period_ptr");
  extern char * Rx_head_ptr asm("Rx_head_ptr");
  extern char * Rx_end_ptr asm("Rx_end_ptr");
  extern char * Update_head_ptr asm("Update_head_ptr");
  extern char * Maskcts asm("Maskcts");
  
  
  SetDriverLong(&Masktx, 0);
  SetDriverLong(&Ctra_val, 0);
  if (Tx_pin >= 0) {
    SetDriverLong(&Masktx, 1<<Tx_pin);
    SetDriverLong(&Ctra_val, 0x10000000 | Tx_pin);
  }
  SetDriverLong(&Maskrx, 0);
  SetDriverLong(&Ctrb_val, 0);
  if (Rx_pin >= 0) {
    SetDriverLong(&Maskrx, 1<<Rx_pin);
    SetDriverLong(&Ctrb_val, 0x54000000 | Rx_pin);
  }
  
  
  SetDriverLong(&Maskcts, 0);
  if(ctspin >= 0){
  	//Set CTS pin to input:
  	DIRA &= ~(1 << ctspin);
  	SetDriverLong(&Maskcts, 1 << ctspin);
  }
  
  
  SetBaud(Rate);
  
  SetDriverLong(&Period_ptr, (int)&half_bit_period_);
  memset( (void *)&rx_buffer_, 0, 1*(kBufferLength));
  
  SetDriverLong(&Rx_head_ptr, (int)&rx_buffer_);
  SetDriverLong(&Rx_end_ptr, (int)&rx_buffer_ + kBufferLength);
  
  rx_head_ = 0;
  rx_tail_ = 0;
  
  SetDriverLong(&Update_head_ptr, (int)&rx_head_);
  write_buf_ptr_ = 1;
  cog_ = 1 + cognew((int)(&(*(int *)&_load_start_serial_cog[0])), (int)(&write_buf_ptr_));
  if (cog_) {
    do {
      //Yield__();
    } while (write_buf_ptr_);
    return true;
  }
  return false;
}



void Serial::Stop(void)
{
  if (cog_) {
    cogstop(cog_ - 1);
    cog_ = 0;
  }
}

bool Serial::SetBaud(int Rate)
{

  return SetBaudClock(Rate, CLKFREQ);
}

bool Serial::SetBaudClock(int Rate, int Sysclock)
{
  int32_t Got_rate = 0;
  Got_rate = (((Shr__(Sysclock, 1)) + (Shr__(Rate, 1))) / Rate);
  half_bit_period_ = (Max__(Got_rate, kMinimumHalfPeriod));
  return Got_rate >= kMinimumHalfPeriod;
}

//void Serial::PutS(const char * string_ptr)
//{
//	PutBuffer(string_ptr, strlen(string_ptr));
//}

void Serial::Put(char char_val)
{
  while (write_buf_ptr_){}
  send_temp_ = char_val;
  write_buf_ptr_ = (int32_t)(&send_temp_);
  
}


int Serial::Put(char * buffer_ptr, int count){
	for(int i = 0; i < count; i++){
		Put(buffer_ptr[i]);
	}
	//while(write_buf_ptr_){} //Wait for it to finish up...
	
	return count;
}


//
// The Put(buffer) function doesn't seem to work in CMM mode. In the tests, I 
// get a -1 for the matching Get(), instead of the character sent. The same code
// can pass in LMM mode.

// Update: now, it doesn't work at all.

//int Serial::PutBuffer(char * buffer_ptr, const bool wait, int buffer_bytes, const char terminator)
//{
//	volatile char * volatile temp_ptr = buffer_ptr;
//	if(buffer_bytes == -1){
//		if(terminator == '\0'){
//			buffer_bytes = strlen(buffer_ptr);
//			
//		}else{
//			for(buffer_bytes = 0; buffer_ptr[buffer_bytes] != terminator; buffer_bytes++){}
//		}
//			
//	}

//	buffer_bytes = 5;

//	if (buffer_bytes > 0 && buffer_ptr != NULL) {
//	
//		send_temp_ = (int)(buffer_ptr);
//    	write_buf_ptr_ = (send_temp_ | ((buffer_bytes - 1) << 16));
//  	}
//	
//	if(wait){
//		while (write_buf_ptr_){}
//	}
//	return buffer_bytes;
//}

int Serial::PutFormatted(const char * format, ...){
	if(format == NULL){
		return 0;
	}
	
	int bytesWritten = 0;
	
	va_list list;
	va_start(list, format);
	
	
	for(int stringIndex = 0; format[stringIndex] != 0; stringIndex++){
	
		if(format[stringIndex] == '%'){
			//Found formatter!
			stringIndex++;
			//Check for flags:
			bool padZero = false;
			int padAmount = 0;
			if(format[stringIndex] == '0'){
				padZero = true;
				stringIndex++;
			}
			if(format[stringIndex] >= '1' and format[stringIndex] <= '9'){
				char paddingBuffer[5];
				int  paddingIndex = 0;
				

//Non freezing version.				
				if(format[stringIndex] >= '0' and format[stringIndex] <= '9'){
					paddingBuffer[paddingIndex++] = format[stringIndex++];
					if(format[stringIndex] >= '0' and format[stringIndex] <= '9'){
						paddingBuffer[paddingIndex++] = format[stringIndex++];
						if(format[stringIndex] >= '0' and format[stringIndex] <= '9'){
							paddingBuffer[paddingIndex++] = format[stringIndex++];
							if(format[stringIndex] >= '0' and format[stringIndex] <= '9'){
								paddingBuffer[paddingIndex++] = format[stringIndex++];
							}
						}
					}
				}

//TODO(SRLM): figure out what is happening with the freezing version.
//I think it freezes because of the CMM and fcache combination.
//Freezing version:				
//				while(format[stringIndex] >= '0' and format[stringIndex] <= '9'){
//					paddingBuffer[paddingIndex++] = format[stringIndex];
////					printf("+%c+", format[stringIndex]);				
//					stringIndex++;
//				}
				paddingBuffer[paddingIndex] = 0;
				padAmount = Numbers::Dec(paddingBuffer);
//				printf("paddingBuffer[0] = %c\r\n", paddingBuffer[0]);
//				printf("paddingBuffer[1] = %c\r\n", paddingBuffer[1]);
//				printf("paddingIndex = %i\r\n", paddingIndex);
//				printf("padAmount: %i\r\n", padAmount);
				

			}
			
				
			
			if(format[stringIndex] == 0){
				break; //TODO(SRLM): What does the real printf do here, when % is followed by 0 (end of string)?
			}
			if(format[stringIndex] == 'd' || format[stringIndex] == 'i'){
				int number = va_arg(list, int);
				int digits = Numbers::DecDigits(number);
				if(padAmount > 0){
					for(int i = padAmount - digits; i > 0; --i){
						Put(' ');
					}
				}
				
				PutFormatted(Numbers::Dec(number));
				bytesWritten += digits;
			}
			else if(format[stringIndex] == 'x' || format[stringIndex] == 'X'){
				int number = va_arg(list, int);
				int digits = Numbers::HexDigits(number);
				if(padAmount > 0){
					for(int i = padAmount - digits; i > 0; --i){
						if(padZero){
							Put('0');
						}else{
							Put(' ');
						}
					}
				}
				
				PutFormatted(Numbers::Hex(number, digits));
				bytesWritten += digits;
			}
			else if(format[stringIndex] == 'c'){
				char character = (char)(va_arg(list, int));
				Put(character);
				bytesWritten++;
			}
			else if(format[stringIndex] == 's'){
				char * string = (char *)(va_arg(list, int));
				while(*string != 0){
					Put(*string++);
					bytesWritten++;
				}
			}
			
			else if(format[stringIndex] == '%'){
				Put('%');
				bytesWritten++;
			}			
			
		}else{
			Put(format[stringIndex]);
			bytesWritten++;
		}
	}
	
	va_end(list);
	return bytesWritten;
}


void Serial::GetFlush(void)
{
  rx_tail_ = rx_head_;
}

int Serial::Get(int timeout)
{
	if(timeout <= -1){ //No timeout, wait forever
		int rxbyte = 0;
		while ((rxbyte = CheckBuffer()) < 0);
		return (char)rxbyte;
	}else{
		int tout = (CLKFREQ/1000)*timeout;
		int rxbyte;
		int totaltime = 0;
		int previous_cnt = CNT;
		int current_cnt;
		do
		{
			rxbyte = CheckBuffer();
			current_cnt = CNT;
			totaltime += current_cnt-previous_cnt;
			previous_cnt = current_cnt;
		}while ( rxbyte < 0 && totaltime < tout);
		return rxbyte;
	}
}

int Serial::Get(char * buffer, int length, int timeout){
	int i;
	for(i = 0; i < length; ++i){
		int character = Get(timeout);
		if(character <= -1){
			return i;
		}
		buffer[i] = (char) character;
	}
	return i;
}

int Serial::Get(char * buffer, char terminator){
	int i;
	char character = terminator + 1; //guarentee that they differ the first time.
	for(i = 0; character != terminator; ++i){
		character = (char)Get();
		buffer[i] = character;
	}
	buffer[i] = '\0';
	return i;
}



int Serial::CheckBuffer(void)
{
  int rxbyte = -1;
  if (rx_tail_ != rx_head_) {
    rxbyte = rx_buffer_[rx_tail_];
    rx_buffer_[rx_tail_] = 0;
    rx_tail_ = ((rx_tail_ + 1) % kBufferLength);
  }
  return rxbyte;
}
