//
// automatically generated by spin2cpp v1.02 on Sat Dec 29 22:32:12 2012
// spin2cpp.linux serial.spin 
//

#include <stdio.h>

#include <propeller.h>
#include "serial.h"


#ifdef __GNUC__
#define INLINE__ static inline
#else
#define INLINE__ static
#endif

INLINE__ int32_t Max__(int32_t a, int32_t b) { return a > b ? a : b; }
INLINE__ int32_t Shr__(uint32_t a, uint32_t b) { return (a>>b); }

extern uint8_t _load_start_serial_cog[];


void SetDriverLong(int index, int value){
    ((int32_t *)&_load_start_serial_cog[index])[0] = value;
}

/* Warning: SetDriverLong(char **, int) must be declared second, otherwise it calls itself! */
void SetDriverLong(char ** index, int value){
    SetDriverLong((int)index, value);
}



bool Serial::Start(int Rx_pin, int Tx_pin, int Rate)
{
    volatile void * reference = NULL;
    __asm__ volatile (
        "mov %[reference], #Fds_entry \n\t"
    :
        [reference] "+r" (reference)
    );

  Stop();

  extern char * Masktx asm("Masktx");
  extern char * Maskrx asm("Maskrx");
  extern char * Ctra_val asm("Ctra_val");
  extern char * Ctrb_val asm("Ctrb_val");
  extern char * Period_ptr asm("Period_ptr");
  extern char * Rx_head_ptr asm("Rx_head_ptr");
  extern char * Rx_end_ptr asm("Rx_end_ptr");
  extern char * Update_head_ptr asm("Update_head_ptr");
  
  
  SetDriverLong(&Masktx, 0);
  SetDriverLong(&Ctra_val, 0);
  if (Tx_pin >= 0) {
    SetDriverLong(&Masktx, 1<<Tx_pin);
    SetDriverLong(&Ctra_val, 0x10000000 | Tx_pin);
  }
  SetDriverLong(&Maskrx, 0);
  SetDriverLong(&Ctrb_val, 0);
  if (Rx_pin >= 0) {
    SetDriverLong(&Maskrx, 1<<Rx_pin);
    SetDriverLong(&Ctrb_val, 0x54000000 | Rx_pin);
  }
  SetBaud(Rate);
  
  SetDriverLong(&Period_ptr, (int)&half_bit_period_);
  memset( (void *)&rx_buffer_, 0, 1*(kBufferLength));
  
  SetDriverLong(&Rx_head_ptr, (int32_t)(&rx_buffer_));
  SetDriverLong(&Rx_end_ptr, (int32_t)(&rx_buffer_) + kBufferLength);
  
  rx_head_ = 0;
  rx_tail_ = 0;
  
  SetDriverLong(&Update_head_ptr, (int32_t)(&rx_head_));
  write_buf_ptr_ = 1;
  cog_ = (1 + cognew((int32_t)(&(*(int32_t *)&_load_start_serial_cog[0])), (int32_t)(&write_buf_ptr_)));
  if (cog_) {
    do {
      //Yield__();
    } while (write_buf_ptr_);
    return -1;
  }
  return true;
}



void Serial::Stop(void)
{
  if (cog_) {
    cogstop(cog_ - 1);
    cog_ = 0;
  }
}

bool Serial::SetBaud(int Rate)
{

  return SetBaudClock(Rate, CLKFREQ);
}

bool Serial::SetBaudClock(int Rate, int Sysclock)
{
  int32_t Got_rate = 0;
  Got_rate = (((Shr__(Sysclock, 1)) + (Shr__(Rate, 1))) / Rate);
  half_bit_period_ = (Max__(Got_rate, kMinimumHalfPeriod));
  return Got_rate >= kMinimumHalfPeriod;
}

//void Serial::PutS(const char * string_ptr)
//{
//	PutBuffer(string_ptr, strlen(string_ptr));
//}

void Serial::Put(char char_val)
{
  send_temp_ = char_val;
  write_buf_ptr_ = (int32_t)(&send_temp_);
  while (write_buf_ptr_);
}

//void Serial::PutBuffer(const char * buffer_ptr, int buffer_bytes)
//{
//	PutBufferNoWait(buffer_ptr, buffer_bytes);
//	WaitForPut();
//}

//void Serial::PutBufferNoWait(const char * buffer_ptr, int buffer_bytes)
//{
//  if (buffer_bytes > 0 && buffer_ptr != NULL) {
//    write_buf_ptr_ = ((int32_t)buffer_ptr | ((buffer_bytes - 1) << 16));
//  }
//}

//void Serial::WaitForPut(void)
//{
//  while (write_buf_ptr_);
//}





//char Serial::GetC(void)
//{
//  int Rxbyte = 0;
//  while ((Rxbyte = GetCCheck()) < 0);
//  return (char)Rxbyte;
//}


int Serial::Put(const char * format, ...){
	if(format == NULL){
		return 0;
	}
	
	int bytesWritten = 0;
	
	va_list list;
	va_start(list, format);
	
	
	for(int stringIndex = 0; format[stringIndex] != 0; stringIndex++){
	
		if(format[stringIndex] == '%'){
			//Found formatter!
			stringIndex++;
			//Check for flags:
			bool padZero = false;
			int padAmount = 0;
			if(format[stringIndex] == '0'){
				padZero = true;
				stringIndex++;
			}
			if(format[stringIndex] >= '1' and format[stringIndex] <= '9'){
				char paddingBuffer[5];
				int  paddingIndex = 0;
				

//Non freezing version.				
				if(format[stringIndex] >= '0' and format[stringIndex] <= '9'){
					paddingBuffer[paddingIndex++] = format[stringIndex++];
					if(format[stringIndex] >= '0' and format[stringIndex] <= '9'){
						paddingBuffer[paddingIndex++] = format[stringIndex++];
						if(format[stringIndex] >= '0' and format[stringIndex] <= '9'){
							paddingBuffer[paddingIndex++] = format[stringIndex++];
							if(format[stringIndex] >= '0' and format[stringIndex] <= '9'){
								paddingBuffer[paddingIndex++] = format[stringIndex++];
							}
						}
					}
				}

//TODO(SRLM): figure out what is happening with the freezing version.
//I think it freezes because of the CMM and fcache combination.
//Freezing version:				
//				while(format[stringIndex] >= '0' and format[stringIndex] <= '9'){
//					paddingBuffer[paddingIndex++] = format[stringIndex];
////					printf("+%c+", format[stringIndex]);				
//					stringIndex++;
//				}
				paddingBuffer[paddingIndex] = 0;
				padAmount = Numbers::Dec(paddingBuffer);
//				printf("paddingBuffer[0] = %c\r\n", paddingBuffer[0]);
//				printf("paddingBuffer[1] = %c\r\n", paddingBuffer[1]);
//				printf("paddingIndex = %i\r\n", paddingIndex);
//				printf("padAmount: %i\r\n", padAmount);
				

			}
			
				
			
			if(format[stringIndex] == 0){
				break; //TODO(SRLM): What does the real printf do here, when % is followed by 0 (end of string)?
			}
			if(format[stringIndex] == 'd' || format[stringIndex] == 'i'){
				int number = va_arg(list, int);
				int digits = Numbers::DecDigits(number);
				if(padAmount > 0){
					for(int i = padAmount - digits; i > 0; --i){
						Put(' ');
					}
				}
				
				Put(Numbers::Dec(number));
				bytesWritten += digits;
			}
			else if(format[stringIndex] == 'x' || format[stringIndex] == 'X'){
				int number = va_arg(list, int);
				int digits = Numbers::HexDigits(number);
				if(padAmount > 0){
					for(int i = padAmount - digits; i > 0; --i){
						if(padZero){
							Put('0');
						}else{
							Put(' ');
						}
					}
				}
				
				Put(Numbers::Hex(number, digits));
				bytesWritten += digits;
			}
			else if(format[stringIndex] == 'c'){
				char character = (char)(va_arg(list, int));
				Put(character);
				bytesWritten++;
			}
			else if(format[stringIndex] == 's'){
				char * string = (char *)(va_arg(list, int));
				while(*string != 0){
					Put(*string++);
					bytesWritten++;
				}
			}
			
			else if(format[stringIndex] == '%'){
				Put('%');
				bytesWritten++;
			}			
			
		}else{
			Put(format[stringIndex]);
			bytesWritten++;
		}
	}
	
	va_end(list);
	return bytesWritten;
}


void Serial::GetFlush(void)
{
  rx_tail_ = rx_head_;
}

int Serial::Get(int timeout)
{
	if(timeout <= -1){ //No timeout, wait forever
		int rxbyte = 0;
		while ((rxbyte = CheckBuffer()) < 0);
		return (char)rxbyte;
	}else{
		int tout = (CLKFREQ/1000)*timeout;
		int rxbyte;
		int totaltime = 0;
		int previous_cnt = CNT;
		int current_cnt;
		do
		{
			rxbyte = CheckBuffer();
			current_cnt = CNT;
			totaltime += current_cnt-previous_cnt;
			previous_cnt = current_cnt;
		}while ( rxbyte < 0 && totaltime < tout);
		return rxbyte;
	}
}

int Serial::Get(char * buffer, int length, int timeout){
	int i;
	for(i = 0; i < length; ++i){
		int character = Get(timeout);
		if(character <= -1){
			return i;
		}
		buffer[i] = (char) character;
	}
	return i;
}

int Serial::Get(char * buffer, char terminator){
	int i;
	char character = terminator + 1; //guarentee that they differ the first time.
	for(i = 0; character != terminator; ++i){
		character = (char)Get();
		buffer[i] = character;
	}
	buffer[i] = '\0';
	return i;
}



int Serial::CheckBuffer(void)
{
  int rxbyte = -1;
  if (rx_tail_ != rx_head_) {
    rxbyte = rx_buffer_[rx_tail_];
    rx_buffer_[rx_tail_] = 0;
    rx_tail_ = ((rx_tail_ + 1) % kBufferLength);
  }
  return rxbyte;
}
//int32_t Serial::Dec(int32_t Value)
//{
//  int32_t	I;
//  int32_t result = 0;
//  if (Value < 0) {
//    Value = (-Value);
//    Tx('-');
//  }
//  I = 1000000000;
//  {
//    int32_t _idx__0000;
//    _idx__0000 = 10;
//    do {
//      if (Value >= I) {
//        Tx(((Value / I) + '0'));
//        Value = (Value % I);
//        result = -1;
//      } else {
//        if ((result) || (I == 1)) {
//          Tx('0');
//        }
//      }
//      I = (I / 10);
//      _idx__0000 = (_idx__0000 + -1);
//    } while (_idx__0000 >= 1);
//  }
//  return result;
//}

//int32_t Serial::Hex(int32_t Value, int32_t Digits)
//{
//  static int32_t look__0001[] = {48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, };

//  Value = (Value << ((8 - Digits) << 2));
//  {
//    int32_t _idx__0002;
//    _idx__0002 = Digits;
//    do {
//      Tx(Lookup__(((Value = (Rotl__(Value, 4))) & 0xf), 0, look__0001, 16));
//      _idx__0002 = (_idx__0002 + -1);
//    } while (_idx__0002 >= 1);
//  }
//  return 0;
//}

//int32_t Serial::Bin(int32_t Value, int32_t Digits)
//{
//  Value = (Value << (32 - Digits));
//  {
//    int32_t _idx__0003;
//    _idx__0003 = Digits;
//    do {
//      Tx((((Value = (Rotl__(Value, 1))) & 0x1) + '0'));
//      _idx__0003 = (_idx__0003 + -1);
//    } while (_idx__0003 >= 1);
//  }
//  return 0;
//}

//int32_t Serial::Atoi(int32_t Strptr)
//{
//  int32_t	Sign;
//  int32_t Int = 0;
//  Sign = 1;
//  while (1) {
//    int32_t _tmp__0004 = ((uint8_t *)Strptr)[0];
//    if (_tmp__0004 == '-') {
//      Sign = (-1);
//    } else if (Between__(_tmp__0004, '0', '9')) {
//      Int = (((Int * 10) + ((uint8_t *)Strptr)[0]) - '0');
//    } else if (1) {
//      break;
//    }
//    (Strptr++);
//  }
//  Int = (Int * Sign);
//  return Int;
//}

//int32_t Serial::Htoi(int32_t Strptr)
//{
//  int32_t	C;
//  int32_t Int = 0;
//  static int32_t look__0005[] = {97, 98, 99, 100, 101, 102, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, };

//  while ((C = Lookdown__(((uint8_t *)(Strptr++))[0], 1, look__0005, 22))) {
//    Int = (Int << 4);
//    Int = (Int | ((C + 9) & 0xf));
//  }
//  return Int;
//}

