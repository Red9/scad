//
// automatically generated by spin2cpp v1.02 on Sat Dec 29 22:32:12 2012
// spin2cpp.linux serial.spin 
//

//TODO (SRLM): check for remaining int32_t, etc.

//TODO(SRLM): Add a destructor that closes the serial port.

//TODO(SRLM): I think the functions with buffer in them should have "volatile"
//in the function declaration (since the buffer can be modified by PASM).

/**

Based on Fast Full-Duplex Serial 1 (FFDS1) version 0.9 by Jonathan Dummer
(lonesock). C++ Port done by SRLM.

Serial provides a fast and stable serial interface using a single cog.

Max baudrate = clkfreq / (86 * 2)

    Clock  | MaxBaud | Standard
    -------+---------+---------
    96 MHz | 558_139 | 500_000    <- 6MHz XTAL at 16x PLL
    80 MHz | 465_116 | 460_800    <- 5MHz XTAL at 16x PLL (most common)
    12 MHz |  69_767 |  57_600    <- approx RCFAST
    20 kHz |     116 | hah hah    <- approx RCSLOW

Bit period is calculated to the nearest 2 clocks. So, the bit period should be
within 1 clock, or 12.5 ns at 80 MHz.

@author SRLM
@date   2013-01-21
@version 1.1

Version History
- 1.1 Added CTS support to suppress tx output from Propeller (2013-04-11)
- 1.0 Initial creation
*/


#ifndef SRLM_PROPGCC_SERIAL_H_
#define SRLM_PROPGCC_SERIAL_H_

#include <stdint.h>
#include <cstdarg>
#include "numbers.h"

class Serial {
public:

/**
Size of the RX buffer in bytes. No restrictions on size (well, Hub RAM limits
[8^) Does not need to be a power of 2. There is no TX buffer, Serial sends
directly from Hub RAM.

@warning: Do not change (it's hardcoded elsewhere)
@todo(SRLM): allow for changing kBufferLength.
*/
//static const int kBufferLength = 256;
static const int kBufferLength = 512;

/**

Set any pin to -1 to disable it.

Starts the Serial PASM engine running in a new cog.
@param rxpin the pin [0..31] for incoming data.
@param txpin the pin [0..31] for outgoing data. Must not equal rxpin. Use -1 to
             disable TX.
@param rate  the initial baud rate in bits per second.
@param ctspin  cts is an input for control of flow from the tx pin. If high, it disables transmissions.
@return  Returns true if the cog started OK, false otherwise
*/
bool Start(int rxpin, int txpin, int rate, int ctspin = -1);

/** Stops the Serial PASM engine, if it is running.
*/
void Stop(void);
  
/** Does a live update of the baud rate in the Serial engine.
@todo(SRLM): Make this return a bool instead of an int...
@param rate desired baud rate of the Serial engine.
@return     -1 if the baud rate was achieved
*/
bool SetBaud(int rate);

/** Does a live update of the baud rate in the Serial engine.

@TODO(SRLM): It looks like it will do this in the middle of a transmission.
			 Should it wait for all TX bytes to be done?

Example:

    got_desired_rate = SetBaudClock( 9600, CLKFREQ )
    got_desired_rate = SetBaudClock( 9600, actual_sys_clock_freq )

@param rate     desired baud rate of the Serial engine.
@param sysclock the system clock (use CLKFREQ), or provide your own (useful when
                using RCFAST).
@return         -1 if the baud rate was achieved
*/
bool SetBaudClock(int rate, int sysclock);
  

/** Sends down a single character.

@param character the byte to send.
*/
void Put(const char character);

int Put(const char * buffer_ptr, const int count);

int Put(const char * buffer_ptr);

// SRLM: Put(buffer) has a bug in it's implementation. I don't know what it is.
//int PutBuffer(char * buffer_ptr, const bool wait = false, int buffer_bytes = -1, const char terminator = '\0');

/** printf function-alike.

This function is based on the requirements found on this page:
http://www.cplusplus.com/reference/cstdio/printf/

@warning This function does not implement the full printf functionality.

Formatters must follow the following prototype:
%[flags][width]specifier

The following flags are supported

- 0 (only with x,X,b,B). Sets padding to the 0 character instead of space.

The following 

This funciton supports the following specifiers:

- d or i : signed decimal integer. The width specifier will pad with spaces if
           necessary.
- x or X : hexdecimal interger. All caps (with either). The width specifier will
           pad with spaces (or 0s if the 0 flag is set) if necessary
- c      : output a single character.
- s      : output a string of characters, 0 terminated.

Each specifier must have a matching optional argument of the correct type.

@param format the string to send, optionally with specifiers.
@param ...    additional arguments. Depending on the format string, the function
              may expect a sequence of additional arguments.
@returns      on success, the total number of characters written. On error, a
              negative number is returned.
*/
int PutFormatted(const char * format, ...);


/**
Waits for a byte to be received or a timeout to occur.
 
@warning This function may block indefinately if timeout is set to a negative
         value, and no data is received.
 
@param   timeout the number of milliseconds to wait. Defaults to forever wait (negative timeout)
@return          -1 if no byte received, 0x00..0xFF if byte
*/
int Get(int timeout = -1);

/** Get a buffer of characters

@param buffer  The buffer to store the received characters in.
@param length  The maximum number of characters to read (may be less than @a
               length if @a timeout is enabled.
@param timeout The maximum amount of time to wait for _each_ character, _not_
               the total time of the function.
@returns the number of characters read. If less than @a length, then a timeout
         occurred.
*/
int Get(char * buffer, int length, int timeout=-1);

/** Get a terminated string of characters

@param buffer     The buffer to store the received characters in. Note: an extra '\0'
                  is always added to the end (null terminate).
@param terminator The last character to put into the buffer. On the first
                  instance of this character, the function returns.
@returns          The number of characters read, including terminator. Does not
                  include null terminator.
*/
int Get(char * buffer, char terminator='\n');

/** Flushes receive buffer.
*/
void GetFlush(void);


/** Get the number of bytes in the receive buffer.
*/

int GetCount(void);


private:


  

/**
Half period must be at least this, otherwise the cog will
sleep for a whole counter cycle (2^32 / clkfreq seconds).
*/
static const int kMinimumHalfPeriod = 86;
  
/**not used directly, but handy to know*/
static const int kXon = 17;
static const int kXoff = 19;
  
/**
The binary version of the PASM driver. Must be binary so that we can do garbage
collection with the linker.
*/  
//static uint8_t dat[];

/** Checks if byte is waiting in the buffer, but doesn't wait.

@return -1 if no byte received, 0x00..0xFF if byte
*/
  int	CheckBuffer(void);

  int32_t	volatile write_buf_ptr_;
  int32_t	volatile send_temp_;
  int32_t	volatile half_bit_period_;
  uint16_t	volatile rx_head_;
  uint16_t	volatile rx_tail_;
  uint8_t	volatile rx_buffer_[kBufferLength];
  uint8_t	cog_;
};


/*
Sends a string over the serial line.
 string_ptr : a pointer to a 0-terminated string in Hub RAM
 Does not transmit the 0 termination.
*/
//  void	PutS(const char * string_ptr);



#endif //SRLM_PROPGCC_SERIAL_H_
