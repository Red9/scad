//
// automatically generated by spin2cpp on Mon Nov 26 21:30:33 2012
// ./spin2cpp.linux --gas FFDS1.spin
//

#include <propeller.h>
#include "FFDS1.h"

#ifdef __GNUC__
#define INLINE__ static inline
#define Yield__() __asm__ volatile( "" ::: "memory" )
#define PostEffect__(X, Y) __extension__({ int32_t tmp__ = (X); (X) = (Y); tmp__; })
#else
#define INLINE__ static
static int32_t tmp__;
#define PostEffect__(X, Y) (tmp__ = (X), (X) = (Y), tmp__)
#define Yield__()
#endif

INLINE__ int32_t Min__(int32_t a, int32_t b)
{
    return a < b ? a : b;
}
INLINE__ int32_t Max__(int32_t a, int32_t b)
{
    return a > b ? a : b;
}
INLINE__ int32_t Rotl__(uint32_t a, uint32_t b)
{
    return (a<<b) | (a>>(32-b));
}
INLINE__ int32_t Rotr__(uint32_t a, uint32_t b)
{
    return (a>>b) | (a<<(32-b));
}
INLINE__ int32_t Shr__(uint32_t a, uint32_t b)
{
    return (a>>b);
}
INLINE__ int32_t Between__(int32_t x, int32_t a, int32_t b)
{
    if (a <= b) return x >= a && x <= b;
    return x >= b && x <= a;
}

INLINE__ int32_t Lookup__(int32_t x, int32_t b, int32_t a[], int32_t n)
{
    int32_t i = (x)-(b);
    return ((unsigned)i >= n) ? 0 : (a)[i];
}

INLINE__ int32_t Lookdown__(int32_t x, int32_t b, int32_t a[], int32_t n)
{
    int32_t i, r;
    r = 0;
    for (i = 0; i < n; i++)
    {
        if (a[i] == x)
        {
            r = i+b;
            break;
        }
    };
    return r;
}

volatile extern uint8_t _load_start_FFDS1_cog[];
__asm__(
    "		.section .FFDS1.cog, \"ax\"\n"
    "		.equ	Buf_len, $3db\n"
    "		.equ	Min_half_period, $56\n"
    "		.equ	Xon, $11\n"
    "		.equ	Xoff, $13\n"
    "		.compress off\n"
    "..start\n"
    "		.org	0\n"
    "Fds_entry\n"
    "		neg	PHSA, #1\n"
    "		mov	CTRA, Ctra_val\n"
    "		mov	DIRA, Masktx\n"
    "		mov	CTRB, Ctrb_val\n"
    "		mov	FRQB, #2\n"
    "		rdlong	Step_clocks, Period_ptr\n"
    "		wrlong	OUTB, PAR\n"
    "		mov	Timestamp, Step_clocks\n"
    "		add	Timestamp, CNT\n"
    "Rx_cleanup\n"
    "		mov	PHSB, #0\n"
    "Rx_main\n"
    "		jmpret	Lockstep_ret, Tx_jump\n"
    "		mov	Bits_in, PHSB	wz\n"
    "	if_z 	jmp	#Rx_main\n"
    "		jmpret	Lockstep_ret, Tx_jump\n"
    "		cmp	Bits_in, Step_clocks	wz, wc\n"
    "	if_b 	jmpret	Lockstep_ret, Tx_jump\n"
    "		mov	Bits_in, #8\n"
    "Rx_main.get_bit\n"
    "		jmpret	Lockstep_ret, Tx_jump\n"
    "		test	Maskrx, INA	wc\n"
    "		rcr	Data_in, #1\n"
    "		jmpret	Lockstep_ret, Tx_jump\n"
    "		djnz	Bits_in, #Rx_main.get_bit\n"
    "		shr	Data_in, #($18)\n"
    "		jmpret	Lockstep_ret, Tx_jump\n"
    "		test	Maskrx, INA	wc\n"
    "	if_nc 	jmp	#Rx_cleanup\n"
    "		add	Rx_ptr, Rx_head_ptr\n"
    "		wrbyte	Data_in, Rx_ptr\n"
    "		add	Rx_ptr, #1\n"
    "		jmpret	Lockstep_ret, Tx_jump\n"
    "		cmpsub	Rx_ptr, Rx_end_ptr	wc\n"
    "	if_nc 	sub	Rx_ptr, Rx_head_ptr\n"
    "		wrword	Rx_ptr, Update_head_ptr\n"
    "		tjz       phsb, #Rx_main wr\n"
    "		nop\n"
    "Tx_jump\n"
    "		jmp	#Tx_main\n"
    "Lockstep\n"
    "		waitcnt	Timestamp, Step_clocks\n"
    "		ror	PHSA, Write_bit\n"
    "Lockstep_ret\n"
    "		jmp	#(0 - 0)\n"
    "Tx_main\n"
    "		rdlong	Bytes_out, PAR\n"
    "		jmpret	Tx_jump, #Lockstep\n"
    "		rdlong	Step_clocks, Period_ptr\n"
    "		jmpret	Tx_jump, #Lockstep\n"
    "		tjz	Bytes_out, #Tx_main\n"
    "		mov	Write_ptr, Bytes_out\n"
    "		shr	Bytes_out, #$10\n"
    "		add	Bytes_out, #1\n"
    "		jmpret	Tx_jump, #Lockstep\n"
    "Tx_main.tx_byte\n"
    "		rdbyte	Tmp, Write_ptr\n"
    "		add	Write_ptr, #1\n"
    "		or	Tmp, #$100\n"
    "		jmpret	Tx_jump, #Lockstep\n"
    "		shl	Tmp, #($20 - 9)\n"
    "		sar	Tmp, #($20 - $a)\n"
    "		mov	PHSA, Tmp\n"
    "		mov	Half_bits_out, #$14\n"
    "Tx_main.tx_bit\n"
    "		jmpret	Tx_jump, #Lockstep\n"
    "		xor	Write_bit, #1\n"
    "		djnz	Half_bits_out, #Tx_main.tx_bit\n"
    "		jmpret	Tx_jump, #Lockstep\n"
    "		djnz	Bytes_out, #Tx_main.tx_byte\n"
    "		wrlong	Bytes_out, PAR\n"
    "		jmpret	Tx_jump, #Lockstep\n"
    "		jmp	#(Tx_main + 1)\n"
    "Period_ptr\n"
    "		.long	0\n"
    "Maskrx\n"
    "		.long	0\n"
    "Masktx\n"
    "		.long	0\n"
    "Rx_head_ptr\n"
    "		.long	0\n"
    "Rx_end_ptr\n"
    "		.long	0\n"
    "Rx_ptr\n"
    "		.long	0\n"
    "Ctra_val\n"
    "		.long	0\n"
    "Ctrb_val\n"
    "		.long	0\n"
    "Write_bit\n"
    "		.long	0\n"
    "Update_head_ptr\n"
    "		.long	0\n"
    "Tmp\n"
    "		.res	1\n"
    "Step_clocks\n"
    "		.res	1\n"
    "Bits_in\n"
    "		.res	1\n"
    "Half_bits_out\n"
    "		.res	1\n"
    "Bytes_out\n"
    "		.res	1\n"
    "Data_in\n"
    "		.res	1\n"
    "Timestamp\n"
    "		.res	1\n"
    "Write_ptr\n"
    "		.res	1\n"
    "		.fit	$1f1\n"
    "    .compress default\n"

);

//{{
//  * Starts the FFDS1 PASM engine running in a new cog.
//  > rx_pin : the pin [0..31] for incoming data.
//  > tx_pin : the pin [0..31] for outgoing data.
//             Must not equal rx_pin.  Use -1 to disable TX.
//  > rate   : the initial baud rate
//  < Returns TRUE (-1) if the cog started OK
//
//  e.g. Start( 31, 30, 460_800 ) ' communicate with the PC over the programming link.
//}}
int32_t FFDS1::Start(int32_t Rx_pin, int32_t Tx_pin, int32_t Rate)
{
    int32_t result = 0;
    Stop();

    //maskTX := ctra_val := 0
    ((int32_t *)&_load_start_FFDS1_cog[264])[0] = (((int32_t *)&_load_start_FFDS1_cog[280])[0] = 0);
    if (Tx_pin >= 0)
    {
        //maskTX := |< tx_pin
        ((int32_t *)&_load_start_FFDS1_cog[264])[0] = (1<<Tx_pin);

        //' use counter A to output bits (NCO single-ended)...if desired
        //ctra_val := constant( %00100 << 26 ) | tx_pin
        ((int32_t *)&_load_start_FFDS1_cog[280])[0] = (0x10000000 | Tx_pin);
    }

    //maskRX := ctrb_val := 0
    ((int32_t *)&_load_start_FFDS1_cog[260])[0] = (((int32_t *)&_load_start_FFDS1_cog[284])[0] = 0);
    if (Rx_pin >= 0)
    {
        //maskRX := |< rx_pin
        ((int32_t *)&_load_start_FFDS1_cog[260])[0] = ((1<<Rx_pin));

        //' use counter B (in LOGIC !A) to see if I need to use the 1st or 2nd sample for RX
        //ctrb_val := constant( %10101 << 26 ) | rx_pin
        ((int32_t *)&_load_start_FFDS1_cog[284])[0] = (0x54000000 | Rx_pin);
    }
    Setbaud(Rate);

    //period_ptr := @half_bit_period
    ((int32_t *)&_load_start_FFDS1_cog[256])[0] = (int32_t)(&Half_bit_period);
    memset( (void *)&Rx_buffer, 0, 1*(Buf_len));

    //rx_head_ptr := @rx_buffer
    ((int32_t *)&_load_start_FFDS1_cog[268])[0] = (int32_t)(&Rx_buffer);

    //rx_end_ptr := @rx_buffer + BUF_LEN
    ((int32_t *)&_load_start_FFDS1_cog[272])[0] = ((int32_t)(&Rx_buffer) + Buf_len);

    Rx_head = 0;
    Rx_tail = 0;

    //update_head_ptr := @rx_head
    ((int32_t *)&_load_start_FFDS1_cog[292])[0] = (int32_t)(&Rx_head);
    Write_buf_ptr = 1;

    //cog := 1 + cognew( @FDS_entry, @write_buf_ptr )
    Cog = (1 + cognew((int32_t)(&(*(int32_t *)&_load_start_FFDS1_cog[0])), (int32_t)(&Write_buf_ptr)));
    if (Cog)
    {
        while (Write_buf_ptr) {}
        return -1;
    }
    return result;
}

int32_t FFDS1::Stop(void)
{
    int32_t result = 0;
    if (Cog)
    {
        cogstop((PostEffect__(Cog, 0) - 1));
    }
    return result;
}

int32_t FFDS1::Setbaud(int32_t Rate)
{
    int32_t Got_rate = 0;
    Got_rate = Setbaudclock(Rate, CLKFREQ);
    return Got_rate;
}

int32_t FFDS1::Setbaudclock(int32_t Rate, int32_t Sysclock)
{
    int32_t Got_rate = 0;
    Got_rate = (((Shr__(Sysclock, 1)) + (Shr__(Rate, 1))) / Rate);
    Half_bit_period = (Max__(Got_rate, Min_half_period));
    Got_rate = -(Got_rate >= Min_half_period);
    return Got_rate;
}

int32_t FFDS1::Str(int32_t String_ptr)
{
    int32_t result = 0;
    if (((uint8_t *)String_ptr)[0])
    {
        Write_buf_ptr = (String_ptr | ((strlen((char *) String_ptr) - 1) << 16));
        do
        {
            Yield__();
        }
        while (Write_buf_ptr);
    }
    return result;
}

int32_t FFDS1::Tx(uint8_t Char_val)
{
    int32_t result = 0;
    Send_temp = (int32_t)Char_val;
    Write_buf_ptr = (int32_t)(&Send_temp);
    while (Write_buf_ptr) {}
    return result;
}

int32_t FFDS1::Txbuf(int32_t Buf_ptr, int32_t Buffer_bytes)
{
    int32_t result = 0;
    if (Buffer_bytes > 0)
    {
        Write_buf_ptr = (Buf_ptr | ((Buffer_bytes - 1) << 16));
        do
        {
            Yield__();
        }
        while (Write_buf_ptr);
    }
    return result;
}

int32_t FFDS1::Txbufnowait(int32_t Buf_ptr, int32_t Buffer_bytes)
{
    int32_t result = 0;
    if (Buffer_bytes > 0)
    {
        Write_buf_ptr = (Buf_ptr | ((Buffer_bytes - 1) << 16));
    }
    return result;
}

int32_t FFDS1::Waitfortx(void)
{
    int32_t result = 0;
    do
    {
        Yield__();
    }
    while (Write_buf_ptr);
    return result;
}

int32_t FFDS1::Rxflush(void)
{
    int32_t result = 0;
    Rx_tail = Rx_head;
    return result;
}

int32_t FFDS1::Rxcheck(void)
{
    int32_t Rxbyte = -1;
    if (Rx_tail != Rx_head)
    {
        Rxbyte = Rx_buffer[Rx_tail];
        Rx_buffer[Rx_tail] = 0;
        Rx_tail = ((Rx_tail + 1) % Buf_len);
    }
    return Rxbyte;
}

int32_t FFDS1::Rxtime(int32_t Ms)
{
    int32_t	Tout;
    int32_t Rxbyte = 0;
    Tout = (((CLKFREQ / 1000) * Ms) + CNT);
    do
    {
        Rxbyte = Rxcheck();
    }
    while ((Rxbyte < 0) && ((CNT - Tout) < 0));
    return Rxbyte;
}

int32_t FFDS1::Rx(void)
{
    int32_t Rxbyte = 0;
    while ((Rxbyte = Rxcheck()) < 0);
    return Rxbyte;
}

int32_t FFDS1::Dec(int32_t Value)
{
    int32_t	I;
    int32_t result = 0;
    if (Value < 0)
    {
        Value = (-Value);
        Tx('-');
    }
    I = 1000000000;
    {
        int32_t _idx__0000;
        _idx__0000 = 10;
        do
        {
            if (Value >= I)
            {
                Tx(((Value / I) + '0'));
                Value = (Value % I);
                result = -1;
            }
            else
            {
                if ((result) || (I == 1))
                {
                    Tx('0');
                }
            }
            I = (I / 10);
            _idx__0000 = (_idx__0000 + -1);
        }
        while (_idx__0000 >= 1);
    }
    return result;
}

int32_t FFDS1::Hex(int32_t Value, int32_t Digits)
{
    int32_t result = 0;
    static int32_t look__0001[] = {48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, };

    Value = (Value << ((8 - Digits) << 2));
    {
        int32_t _idx__0002;
        _idx__0002 = Digits;
        do
        {
            Tx(Lookup__(((Value = (Rotl__(Value, 4))) & 0xf), 0, look__0001, 16));
            _idx__0002 = (_idx__0002 + -1);
        }
        while (_idx__0002 >= 1);
    }
    return result;
}

int32_t FFDS1::Bin(int32_t Value, int32_t Digits)
{
    int32_t result = 0;
    Value = (Value << (32 - Digits));
    {
        int32_t _idx__0003;
        _idx__0003 = Digits;
        do
        {
            Tx((((Value = (Rotl__(Value, 1))) & 0x1) + '0'));
            _idx__0003 = (_idx__0003 + -1);
        }
        while (_idx__0003 >= 1);
    }
    return result;
}

int32_t FFDS1::Atoi(int32_t Strptr)
{
    int32_t	Sign;
    int32_t Int = 0;
    Sign = 1;
    while (1)
    {
        int32_t _tmp__0004 = ((uint8_t *)Strptr)[0];
        if (_tmp__0004 == '-')
        {
            Sign = (-1);
        }
        else if (Between__(_tmp__0004, '0', '9'))
        {
            Int = (((Int * 10) + ((uint8_t *)Strptr)[0]) - '0');
        }
        else if (1)
        {
            break;
        }
        (Strptr++);
    }
    Int = (Int * Sign);
    return Int;
}

int32_t FFDS1::Htoi(int32_t Strptr)
{
    int32_t	C;
    int32_t Int = 0;
    static int32_t look__0005[] = {97, 98, 99, 100, 101, 102, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, };

    while ((C = Lookdown__(((uint8_t *)(Strptr++))[0], 1, look__0005, 22)))
    {
        Int = (Int << 4);
        Int = (Int | ((C + 9) & 0xf));
    }
    return Int;
}

