//
// automatically generated by spin2cpp v1.01 on Wed Dec 12 21:35:05 2012
// spin2cpp.linux --main test_nl.spin 
//

#include <propeller.h>
#include "fsrw.h"

#ifdef __GNUC__
#define INLINE__ static inline
#define PostEffect__(X, Y) __extension__({ int32_t tmp__ = (X); (X) = (Y); tmp__; })
#else
#define INLINE__ static
static int32_t tmp__;
#define PostEffect__(X, Y) (tmp__ = (X), (X) = (Y), tmp__)
#endif

INLINE__ int32_t Min__(int32_t a, int32_t b) { return a < b ? a : b; }
INLINE__ int32_t Max__(int32_t a, int32_t b) { return a > b ? a : b; }
INLINE__ int32_t Shr__(uint32_t a, uint32_t b) { return (a>>b); }
int32_t fsrwSpin::Release(void)
{
  int32_t result = 0;
  Sdspi.Release();
  return result;
}

int32_t fsrwSpin::Writeblock2(int32_t N, int32_t B)
{
  int32_t result = 0;
  Errno = Sdspi.Writeblock(N, B);
  if (Errno < 0) {
    return Errno;
  }
  if (N >= Fat1) {
    if (N < (Fat1 + Sectorsperfat)) {
      Errno = Sdspi.Writeblock((N + Sectorsperfat), B);
      if (Errno < 0) {
        return Errno;
      }
    }
  }
  return result;
}

int32_t fsrwSpin::Flushifdirty(void)
{
  int32_t result = 0;
  if (Dirty) {
    Errno = Writeblock2(Lastread, (int32_t)(&Buf2));
    if (Errno < 0) {
      return Errno;
    }
    Dirty = 0;
  }
  return result;
}

int32_t fsrwSpin::Readblockc(int32_t N)
{
  int32_t result = 0;
  if (N != Lastread) {
    Errno = Flushifdirty();
    if (Errno < 0) {
      return Errno;
    }
    Errno = Sdspi.Readblock(N, (int32_t)(&Buf2));
    if (Errno < 0) {
      return Errno;
    }
    Lastread = N;
  }
  return result;
}

int32_t fsrwSpin::Brword(int32_t B)
{
  int32_t result = 0;
  return (((uint8_t *)B)[0] + (((uint8_t *)B)[1] << 8));
}

int32_t fsrwSpin::Brlong(int32_t B)
{
  int32_t result = 0;
  return (Brword(B) + (Brword((B + 2)) << 16));
}

int32_t fsrwSpin::Brclust(int32_t B)
{
  int32_t result = 0;
  if (Filesystem == 1) {
    return Brword(B);
  } else {
    return Brlong(B);
  }
}

int32_t fsrwSpin::Brwword(int32_t W, int32_t V)
{
  int32_t result = 0;
  ((uint8_t *)(W++))[0] = V;
  ((uint8_t *)W)[0] = (Shr__(V, 8));
  Dirty = 1;
  return result;
}

int32_t fsrwSpin::Brwlong(int32_t W, int32_t V)
{
  int32_t result = 0;
  Brwword(W, V);
  Brwword((W + 2), (Shr__(V, 16)));
  return result;
}

int32_t fsrwSpin::Brwclust(int32_t W, int32_t V)
{
  int32_t result = 0;
  if (Filesystem == 1) {
    Brwword(W, V);
  } else {
    Brwlong(W, V);
  }
  return result;
}

int32_t fsrwSpin::Unmount(void)
{
  int32_t result = 0;
  Errno = Pclose();
  if (Errno < 0) {
    return Errno;
  }
  Sdspi.Stop();
  return result;
}

int32_t fsrwSpin::Getfstype(void)
{
  int32_t R = 0;
  if ((Brlong(((int32_t)(&Buf) + 54)) == 0x31544146) && (Buf[58] == '6')) {
    return 1;
  }
  if ((Brlong(((int32_t)(&Buf) + 82)) == 0x33544146) && (Buf[86] == '2')) {
    return 2;
  }
  return R;
}

int32_t fsrwSpin::Mount_explicit(int32_t Do, int32_t Clk, int32_t Di, int32_t Cs)
{
  int32_t	Start, Sectorspercluster, Reserved, Rootentries, Sectors;
  int32_t R = 0;
  if (Pdate == 0) {
    Pdate = 0x3a3b3800;
  }
  Errno = Unmount();
  if (Errno < 0) {
    return Errno;
  }
  Sdspi.Start_explicit(Do, Clk, Di, Cs);
  Lastread = (-1);
  Dirty = 0;
  Errno = Sdspi.Readblock(0, (int32_t)(&Buf));
  if (Errno < 0) {
    return Errno;
  }
  if (Getfstype() > 0) {
    Start = 0;
  } else {
    Start = Brlong(((int32_t)(&Buf) + 454));
    Errno = Sdspi.Readblock(Start, (int32_t)(&Buf));
    if (Errno < 0) {
      return Errno;
    }
  }
  Filesystem = Getfstype();
  if (Filesystem == 0) {
    return (-20);
  }
  if (Brword(((int32_t)(&Buf) + 11)) != Sectorsize) {
    return (-21);
  }
  Sectorspercluster = Buf[13];
  if (Sectorspercluster & (Sectorspercluster - 1)) {
    return (-22);
  }
  Clustershift = 0;
  while (Sectorspercluster > 1) {
    (Clustershift++);
    Sectorspercluster = (Shr__(Sectorspercluster, 1));
  }
  Sectorspercluster = (1 << Clustershift);
  Clustersize = (Sectorsize << Clustershift);
  Reserved = Brword(((int32_t)(&Buf) + 14));
  if (Buf[16] != 2) {
    return (-23);
  }
  Sectors = Brword(((int32_t)(&Buf) + 19));
  if (Sectors == 0) {
    Sectors = Brlong(((int32_t)(&Buf) + 32));
  }
  Fat1 = (Start + Reserved);
  if (Filesystem == 2) {
    Rootentries = (16 << Clustershift);
    Sectorsperfat = Brlong(((int32_t)(&Buf) + 36));
    Dataregion = ((Fat1 + (2 * Sectorsperfat)) - (2 * Sectorspercluster));
    Rootdir = ((Dataregion + (Brword(((int32_t)(&Buf) + 44)) << Clustershift)) << Sectorshift);
    Rootdirend = (Rootdir + (Rootentries << Dirshift));
    Endofchain = 268435440;
  } else {
    Rootentries = Brword(((int32_t)(&Buf) + 17));
    Sectorsperfat = Brword(((int32_t)(&Buf) + 22));
    Rootdir = ((Fat1 + (2 * Sectorsperfat)) << Sectorshift);
    Rootdirend = (Rootdir + (Rootentries << Dirshift));
    Dataregion = ((1 + (Shr__((Rootdirend - 1), Sectorshift))) - (2 * Sectorspercluster));
    Endofchain = 65520;
  }
  if (Brword(((int32_t)(&Buf) + 510)) != 43605) {
    return (-24);
  }
  Totclusters = (Shr__(((Sectors - Dataregion) + Start), Clustershift));
  return R;
}

int32_t fsrwSpin::Mount(int32_t Basepin)
{
  int32_t	Start, Sectorspercluster, Reserved, Rootentries, Sectors;
  int32_t R = 0;
  return Mount_explicit(Basepin, (Basepin + 1), (Basepin + 2), (Basepin + 3));
}

int32_t fsrwSpin::Readbytec(int32_t Byteloc)
{
  int32_t result = 0;
  Errno = Readblockc((Shr__(Byteloc, Sectorshift)));
  if (Errno < 0) {
    return Errno;
  }
  return ((int32_t)(&Buf2) + (Byteloc & 0x1ff));
}

int32_t fsrwSpin::Readfat(int32_t Clust)
{
  int32_t result = 0;
  Fatptr = ((Fat1 << Sectorshift) + (Clust << Filesystem));
  return Readbytec(Fatptr);
}

int32_t fsrwSpin::Followchain(void)
{
  int32_t	Temp;
  int32_t R = 0;
  Temp = Readfat(Fclust);
  if (Temp < 0) {
    return Temp;
  }
  R = Brclust(Temp);
  Writelink = Fatptr;
  return R;
}

int32_t fsrwSpin::Nextcluster(void)
{
  int32_t R = 0;
  R = Followchain();
  if (R < 0) {
    return R;
  }
  if ((R < 2) || (R >= Totclusters)) {
    return (-9);
  }
  return R;
}

int32_t fsrwSpin::Freeclusters(int32_t Clust)
{
  int32_t	Bp;
  int32_t result = 0;
  while (Clust < Endofchain) {
    if (Clust < 2) {
      return (-26);
    }
    Bp = Readfat(Clust);
    if (Bp < 0) {
      return Bp;
    }
    Clust = Brclust(Bp);
    Brwclust(Bp, 0);
  }
  Errno = Flushifdirty();
  if (Errno < 0) {
    return Errno;
  }
  return result;
}

int32_t fsrwSpin::Datablock(void)
{
  int32_t result = 0;
  return (((Fclust << Clustershift) + Dataregion) + ((Shr__(Floc, Sectorshift)) & ((1 << Clustershift) - 1)));
}

int32_t fsrwSpin::Uc(int32_t C)
{
  int32_t result = 0;
  if (('a' <= C) && (C <= 'z')) {
    return (C - 32);
  }
  return C;
}

int32_t fsrwSpin::Pflushbuf(int32_t Rcnt, int32_t Metadata)
{
  int32_t	Cluststart, Newcluster, Count, I;
  int32_t R = 0;
  if (Direntry == 0) {
    return (-27);
  }
  if (Rcnt > 0) {
    if (Frem < Sectorsize) {
      Newcluster = (-1);
      Cluststart = (Fclust & (~((Shr__(Sectorsize, Filesystem)) - 1)));
      Count = 2;
      while (1) {
        Errno = Readfat(Cluststart);
        if (Errno < 0) {
          return Errno;
        }
        {
          int32_t _limit__0025 = (Sectorsize - (1 << Filesystem));
          int32_t _step__0026 = (1 << Filesystem);
          I = 0;
          if (I >= _limit__0025) _step__0026 = -_step__0026;
          do {
            if (Buf2[I] == 0) {
              if (Brclust(((int32_t)(&Buf2) + I)) == 0) {
                Newcluster = (Cluststart + (Shr__(I, Filesystem)));
                if (Newcluster >= Totclusters) {
                  Newcluster = (-1);
                }
                break;
              }
            }
            I = (I + _step__0026);
          } while (((_step__0026 > 0) && (I <= _limit__0025)) || ((_step__0026 < 0) && (I >= _limit__0025)));
        }
        if (Newcluster > 1) {
          Brwclust(((int32_t)(&Buf2) + I), (Endofchain + 15));
          if (Writelink == 0) {
            Errno = Brwword((Readbytec(Direntry) + 26), Newcluster);
            if (Errno < 0) {
              return Errno;
            }
            Writelink = (Direntry & (Sectorsize - Filesystem));
            Brwlong((((int32_t)(&Buf2) + Writelink) + 28), (Floc + Bufat));
            if (Filesystem == 2) {
              Brwword((((int32_t)(&Buf2) + Writelink) + 20), (Shr__(Newcluster, 16)));
            }
          } else {
            Errno = Brwclust(Readbytec(Writelink), Newcluster);
            if (Errno < 0) {
              return Errno;
            }
          }
          Writelink = (Fatptr + I);
          Fclust = Newcluster;
          Frem = Clustersize;
          break;
        } else {
          Cluststart = (Cluststart + (Shr__(Sectorsize, Filesystem)));
          if (Cluststart >= Totclusters) {
            Cluststart = 0;
            (Count--);
            if (Rcnt < 0) {
              Rcnt = (-5);
              break;
            }
          }
        }
      }
    }
    if (Frem >= Sectorsize) {
      Errno = Sdspi.Writeblock(Datablock(), (int32_t)(&Buf));
      if (Errno < 0) {
        return Errno;
      }
      if (Rcnt == Sectorsize) {
        Floc = (Floc + Rcnt);
        Frem = (Frem - Rcnt);
        Bufat = 0;
        Bufend = Rcnt;
      }
    }
  }
  if ((Rcnt < 0) || (Metadata)) {
    Errno = Readblockc((Shr__(Direntry, Sectorshift)));
    if (Errno < 0) {
      return Errno;
    }
    Brwlong((((int32_t)(&Buf2) + (Direntry & (Sectorsize - Filesystem))) + 28), (Floc + Bufat));
    Errno = Flushifdirty();
    if (Errno < 0) {
      return Errno;
    }
  }
  if (Rcnt < 0) {
    return Rcnt;
  }
  return Rcnt;
}

int32_t fsrwSpin::Pflush(void)
{
  int32_t result = 0;
  return Pflushbuf(Bufat, 1);
}

int32_t fsrwSpin::Pfillbuf(void)
{
  int32_t R = 0;
  if (Floc >= Filesize) {
    return (-1);
  }
  if (Frem == 0) {
    Fclust = Nextcluster();
    if (Fclust < 0) {
      return Fclust;
    }
    Frem = (Min__(Clustersize, (Filesize - Floc)));
  }
  Errno = Sdspi.Readblock(Datablock(), (int32_t)(&Buf));
  if (Errno < 0) {
    return Errno;
  }
  R = Sectorsize;
  if ((Floc + R) >= Filesize) {
    R = (Filesize - Floc);
  }
  Floc = (Floc + R);
  Frem = (Frem - R);
  Bufat = 0;
  Bufend = R;
  return R;
}

int32_t fsrwSpin::Pclose(void)
{
  int32_t R = 0;
  if (Direntry) {
    R = Pflush();
    if (R < 0) {
      return R;
    }
  }
  Bufat = 0;
  Bufend = 0;
  Filesize = 0;
  Floc = 0;
  Frem = 0;
  Writelink = 0;
  Direntry = 0;
  Fclust = 0;
  Firstcluster = 0;
  Sdspi.Release();
  return R;
}

int32_t fsrwSpin::Setdate(int32_t Year, int32_t Month, int32_t Day, int32_t Hour, int32_t Minute, int32_t Second)
{
  int32_t result = 0;
  Pdate = ((((Year - 1980) << 25) + (Month << 21)) + (Day << 16));
  Pdate = (Pdate + (((Hour << 11) + (Minute << 5)) + (Shr__(Second, 1))));
  return result;
}

int32_t fsrwSpin::Popen(int32_t S, int32_t Mode)
{
  int32_t	I, Sentinel, Dirptr, Freeentry;
  int32_t R = 0;
  Errno = Pclose();
  if (Errno < 0) {
    return Errno;
  }
  I = 0;
  while (((I < 8) && (((uint8_t *)S)[0])) && (((uint8_t *)S)[0] != '.')) {
    Padname[(I++)] = Uc(((uint8_t *)(S++))[0]);
  }
  while (I < 8) {
    Padname[(I++)] = ' ';
  }
  while ((((uint8_t *)S)[0]) && (((uint8_t *)S)[0] != '.')) {
    (S++);
  }
  if (((uint8_t *)S)[0] == '.') {
    (S++);
  }
  while ((I < 11) && (((uint8_t *)S)[0])) {
    Padname[(I++)] = Uc(((uint8_t *)(S++))[0]);
  }
  while (I < 11) {
    Padname[(I++)] = ' ';
  }
  Sentinel = 0;
  Freeentry = 0;
  {
    int32_t _limit__0027 = (Rootdirend - Dirsize);
    int32_t _step__0028 = Dirsize;
    Dirptr = Rootdir;
    if (Dirptr >= _limit__0027) _step__0028 = -_step__0028;
    do {
      S = Readbytec(Dirptr);
      if (S < 0) {
        return S;
      }
      if ((Freeentry == 0) && ((((uint8_t *)S)[0] == 0) || (((uint8_t *)S)[0] == 229))) {
        Freeentry = Dirptr;
      }
      if (((uint8_t *)S)[0] == 0) {
        Sentinel = Dirptr;
        break;
      }
      I = 0;
      do {
        if (Padname[I] != ((uint8_t *)S)[I]) {
          break;
        }
        I = (I + 1);
      } while (I <= 10);
      if ((I == 11) && (0 == (((uint8_t *)S)[11] & 0x18))) {
        Fclust = Brword((S + 26));
        if (Filesystem == 2) {
          Fclust = (Fclust + (Brword((S + 20)) << 16));
        }
        Firstcluster = Fclust;
        Filesize = Brlong((S + 28));
        if (Mode == 'r') {
          Frem = (Min__(Clustersize, Filesize));
          return 0;
        }
        if (((uint8_t *)S)[11] & 0xd9) {
          return (-6);
        }
        if (Mode == 'd') {
          Brwword(S, 229);
          if (Fclust) {
            Errno = Freeclusters(Fclust);
            if (Errno < 0) {
              return Errno;
            }
          }
          Errno = Flushifdirty();
          if (Errno < 0) {
            return Errno;
          }
          return 0;
        }
        if (Mode == 'w') {
          Brwword((S + 26), 0);
          Brwword((S + 20), 0);
          Brwlong((S + 28), 0);
          Writelink = 0;
          Direntry = Dirptr;
          if (Fclust) {
            Errno = Freeclusters(Fclust);
            if (Errno < 0) {
              return Errno;
            }
          }
          Bufend = Sectorsize;
          Fclust = 0;
          Filesize = 0;
          Frem = 0;
          return 0;
        } else {
          if (Mode == 'a') {
            Frem = Filesize;
            Freeentry = Clustersize;
            if (Fclust >= Endofchain) {
              Fclust = 0;
            }
            while (Frem > Freeentry) {
              if (Fclust < 2) {
                return (-7);
              }
              Fclust = Nextcluster();
              if (Fclust < 0) {
                return Fclust;
              }
              Frem = (Frem - Freeentry);
            }
            Floc = (Filesize & 0xfffffe00);
            Bufend = Sectorsize;
            Bufat = (Frem & 0x1ff);
            Writelink = 0;
            Direntry = Dirptr;
            if (Bufat) {
              Errno = Sdspi.Readblock(Datablock(), (int32_t)(&Buf));
              if (Errno < 0) {
                return Errno;
              }
              Frem = (Freeentry - (Floc & (Freeentry - 1)));
            } else {
              if ((Fclust < 2) || (Frem == Freeentry)) {
                Frem = 0;
              } else {
                Frem = (Freeentry - (Floc & (Freeentry - 1)));
              }
            }
            if (Fclust >= 2) {
              Errno = Followchain();
              if (Errno < 0) {
                return Errno;
              }
            }
            return 0;
          } else {
            return (-3);
          }
        }
      }
      Dirptr = (Dirptr + _step__0028);
    } while (((_step__0028 > 0) && (Dirptr <= _limit__0027)) || ((_step__0028 < 0) && (Dirptr >= _limit__0027)));
  }
  if ((Mode != 'w') && (Mode != 'a')) {
    return (-1);
  }
  Direntry = Freeentry;
  if (Direntry == 0) {
    return (-2);
  }
  S = Readbytec(Direntry);
  if (S < 0) {
    return S;
  }
  memset( (void *)S, 0, 1*(Dirsize));
  memcpy( (void *)S, (void *)&Padname, 1*(11));
  Brwword((S + 26), 0);
  Brwword((S + 20), 0);
  I = Pdate;
  Brwlong((S + 14), I);
  Brwlong((S + 22), I);
  if ((Direntry == Sentinel) && ((Direntry + Dirsize) < Rootdirend)) {
    Errno = Brwword(Readbytec((Direntry + Dirsize)), 0);
    if (Errno < 0) {
      return Errno;
    }
  }
  Errno = Flushifdirty();
  if (Errno < 0) {
    return Errno;
  }
  Writelink = 0;
  Fclust = 0;
  Bufend = Sectorsize;
  return R;
}

int32_t fsrwSpin::Get_filesize(void)
{
  int32_t result = 0;
  return Filesize;
}

int32_t fsrwSpin::Pread(int32_t Ubuf, int32_t Count)
{
  int32_t	T;
  int32_t R = 0;
  while (Count > 0) {
    if (Bufat >= Bufend) {
      T = Pfillbuf();
      if (T <= 0) {
        return T;
      }
    }
    T = (Min__((Bufend - Bufat), Count));
    if (((T | Ubuf) | Bufat) & 0x3) {
      memcpy( (void *)Ubuf, (void *)(void *)(((int32_t)(&Buf) + Bufat)), 1*(T));
    } else {
      memmove( (void *)Ubuf, (void *)(void *)(((int32_t)(&Buf) + Bufat)), 4*((Shr__(T, 2))));
    }
    Bufat = (Bufat + T);
    R = (R + T);
    Ubuf = (Ubuf + T);
    Count = (Count - T);
  }
  return R;
}

int32_t fsrwSpin::Pgetc(void)
{
  int32_t	T;
  int32_t result = 0;
  if (Bufat >= Bufend) {
    T = Pfillbuf();
    if (T < (-1)) {
      return T;
    }
    if (T <= 0) {
      return (-1);
    }
  }
  return Buf[(Bufat++)];
}

int32_t fsrwSpin::Pwrite(int32_t Ubuf, int32_t Count)
{
  int32_t	T;
  int32_t R = 0;
  while (Count > 0) {
    if (Bufat >= Bufend) {
      Errno = Pflushbuf(Bufat, 0);
      if (Errno < 0) {
        return Errno;
      }
    }
    T = (Min__((Bufend - Bufat), Count));
    if (((T | Ubuf) | Bufat) & 0x3) {
      memcpy( (void *)(void *)(((int32_t)(&Buf) + Bufat)), (void *)Ubuf, 1*(T));
    } else {
      memmove( (void *)(void *)(((int32_t)(&Buf) + Bufat)), (void *)Ubuf, 4*((Shr__(T, 2))));
    }
    R = (R + T);
    Bufat = (Bufat + T);
    Ubuf = (Ubuf + T);
    Count = (Count - T);
  }
  return R;
}

int32_t fsrwSpin::Pputs(int32_t B)
{
  int32_t result = 0;
  return Pwrite(B, strlen((char *) B));
}

int32_t fsrwSpin::Pputc(int32_t C)
{
  int32_t R = 0;
  if (Bufat == Sectorsize) {
    if (Pflushbuf(Sectorsize, 0) < 0) {
      return (-1);
    }
  }
  Buf[(Bufat++)] = C;
  return R;
}

int32_t fsrwSpin::Seek(int32_t Pos)
{
  int32_t	Delta;
  int32_t result = 0;
  if (((Direntry) || (Pos < 0)) || (Pos > Filesize)) {
    return (-1);
  }
  Delta = ((Floc - Bufend) & (-Clustersize));
  if (Pos < Delta) {
    Fclust = Firstcluster;
    Frem = (Min__(Clustersize, Filesize));
    Floc = 0;
    Bufat = 0;
    Bufend = 0;
    Delta = 0;
  }
  while (Pos >= (Delta + Clustersize)) {
    Fclust = Nextcluster();
    if (Fclust < 0) {
      return Fclust;
    }
    Floc = (Floc + Clustersize);
    Delta = (Delta + Clustersize);
    Frem = (Min__(Clustersize, (Filesize - Floc)));
    Bufat = 0;
    Bufend = 0;
  }
  if (((Bufend == 0) || (Pos < (Floc - Bufend))) || (Pos >= ((Floc - Bufend) + Sectorsize))) {
    Delta = (Floc + Frem);
    Floc = (Pos & 0xfffffe00);
    Frem = (Delta - Floc);
    Errno = Pfillbuf();
    if (Errno < (-1)) {
      return Errno;
    }
  }
  Bufat = (Pos & 0x1ff);
  return 0;
}

int32_t fsrwSpin::Tell(void)
{
  int32_t result = 0;
  return ((Floc + Bufat) - Bufend);
}

int32_t fsrwSpin::Opendir(void)
{
  int32_t	Off;
  int32_t result = 0;
  Errno = Pclose();
  if (Errno < 0) {
    return Errno;
  }
  Off = (Rootdir - (Dataregion << Sectorshift));
  Fclust = (Shr__(Off, (Clustershift + Sectorshift)));
  Floc = (Off - (Fclust << (Clustershift + Sectorshift)));
  Frem = (Rootdirend - Rootdir);
  Filesize = (Floc + Frem);
  return 0;
}

int32_t fsrwSpin::Nextfile(int32_t Fbuf)
{
  int32_t	I, T, At, Lns;
  int32_t result = 0;
  while (1) {
    if (Bufat >= Bufend) {
      T = Pfillbuf();
      if (T < 0) {
        return T;
      }
      if (((Shr__(Floc, Sectorshift)) & ((1 << Clustershift) - 1)) == 0) {
        (Fclust++);
      }
    }
    At = ((int32_t)(&Buf) + Bufat);
    if (((uint8_t *)At)[0] == 0) {
      return (-1);
    }
    Bufat = (Bufat + Dirsize);
    if ((((uint8_t *)At)[0] != 229) && ((((uint8_t *)At)[11] & 0x18) == 0)) {
      Lns = Fbuf;
      I = 0;
      do {
        ((uint8_t *)Fbuf)[0] = ((uint8_t *)At)[I];
        (Fbuf++);
        if (((uint8_t *)At)[I] != ' ') {
          Lns = Fbuf;
        }
        if ((I == 7) || (I == 10)) {
          Fbuf = Lns;
          if (I == 7) {
            ((uint8_t *)Fbuf)[0] = '.';
            (Fbuf++);
          }
        }
        I = (I + 1);
      } while (I <= 10);
      ((uint8_t *)Fbuf)[0] = 0;
      return 0;
    }
  }
  return result;
}

int32_t fsrwSpin::Getclustersize(void)
{
  int32_t result = 0;
  return Clustersize;
}

int32_t fsrwSpin::Getclustercount(void)
{
  int32_t result = 0;
  return Totclusters;
}

