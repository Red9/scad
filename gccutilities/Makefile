#
# The following parameters can be defined:
# ROOT: the path to the Propeller GCC folder (propgcc, most likely)
# MODEL: the memory model to use.
# DEFINEFLAGS: ... ???

# If Unit tests are being run, the #define UNIT_TEST flag is set.

ifndef MODEL
MODEL = cmm
endif

#If no root given, make best guess
ifndef ROOT
ROOT=$(shell root=$$(pwd); while [ "$$(basename $$root)" != "propgcc" ]; do root=$$(dirname $$root); done; echo $$root"/")
endif

ifndef DEFINEFLAGS
DEFINEFLAGS =
endif

#Note the "string" version of *.cpp: that's so that the gcc compiler evaluates
#the wildcard, instead of make. This is because unit testing generates a .cpp
#file with the ruby command, and wildcard evaluates before it's generated.
#Have to do the wildcard *.S because otherwise gcc complains if there are not
#any .S files in the directory (if you pass it a *.S).
SRCS=*.cpp $(wildcard *.S) #$(wildcard *.cpp) $(wildcard *.S)
OBJS=$(subst .cpp,.o,$(SRCS))

UNITYPATH = ${ROOT}unity/
GCCUTILITIESPATH = ${ROOT}gccutilities/
BOARDCONFIGURATIONPATH = ${ROOT}boardconfiguration/

INCLUDE = -I${UNITYPATH} -I${GCCUTILITIESPATH} -I${BOARDCONFIGURATIONPATH} -I../

#-Wa,-alh,-L  == output to STDOUT the generated assembly, with C interspersed



DEBUGFLAGS = #-Wall -Wa,-alh,-L #-save-temps #-ftime-report -fmem-report #-Q

CXX = propeller-elf-g++
CLD = propeller-elf-ld
#-Wall

OPTIMIZEFLAGS = -Os -fno-exceptions -ffunction-sections -fdata-sections -fno-rtti -m32bit-doubles -mfcache -fpermissive
CXXFLAGS = -m${MODEL} ${INCLUDE} ${DEBUGFLAGS} ${DEFINEFLAGS} ${OPTIMIZEFLAGS} -std=gnu++0x -fno-strict-aliasing 
CLDFLAGS = #-Wl,--gc-sections #-Wl,--print-gc-sections #-Wl,--verbose #-Wl,--script=${GCCUTILITIESPATH}main.ld 

Debug:
	${CXX} ${CXXFLAGS} ${CLDFLAGS} -o main.elf ${SRCS}
	
Unit:
	ruby ${ROOT}/gccutilities/generate_test_runner.rb
	${CXX} ${CXXFLAGS} ${CLDFLAGS} -o main.elf -D UNIT_TEST ${SRCS} ${UNITYPATH}unity.cpp
	rm -f *.generate.*

cleanDebug: clean

clean:
	${RM} *.o *.elf *.map *.rawmap a.out *.generate.*

